[
{
	"uri": "/tutorials/git/",
	"title": "Git",
	"tags": ["git"],
	"description": "Conteudo relacionado a Git",
	"content": "GIT O Git √© uma ferramenta de controle de vers√µes ampliamente reconhecida como um standard no mundo TI.\n"
},
{
	"uri": "/tutorials/git/git-basico/",
	"title": "Tutorial - Git B√°sico",
	"tags": ["git"],
	"description": "Tutorial de GIT B√°sico",
	"content": "Intro Nesse tutorial, vamos fazer opera√ß√µes b√°sicas relacionadas ao Git. como initializar um reposit√≥rio, adicionar arquivos, comittar as mudan√ßas, depois modificar os arquivos, adicionar os arquivos modificados, comittar tudo de novo, e por fim algumas no√ß√µes b√°sicas relacionadas a branch e merges.\nPrerequisitos  Ter o git instalado, sen√£o rodar: sudo apt-get install git Instalar git-bash-prompt seguindo este tutorial Ter uma estacao de trabalho Linux  1. Inicializando o repositorio Crie uma pasta chamada tutorial-git. Entre nela e rode o comando git init\ncd ~ mkdir projetos cd projetos mkdir tutorial-git cd tutorial-git git init   2. Primeiro commit Agora, experimente criar um arquivo chamado test.txt, com uma √∫nica linha contendo Hello World. Em seguida, execute o comando git add test.txt seguido de git commit -m 'First commit'.\nComo esse √© o seu primeiro commit e o Git n√£o sabe nada sobre voc√™, √© necess√°rio adicionar algumas informa√ß√µes (o Git emitir√° um erro sempre que voc√™ tentar comittar sem essas informa√ß√µes devidamente registradas), como nome e e-mail, para que o Git saiba quem est√° fazendo o commit e poder registrar essa informa√ß√£o no reposit√≥rio.\nPara ajustar isso, execute o comando git config --global user.name '[seu nome]' para configurar o seu nome (substitua [seu nome] pelo seu nome nesse comando) e git config --global user.email '[seu e-mail]' para configurar o seu e-mail (substitua [seu e-mail] pelo seu e-mail nesse comando)\nAp√≥s executar esses dois comandos, execute novamente o comando git commit -m 'First commit'. Agora sim, seu primeiro commit estar√° registrado!\n  Note que o Git registrar√°, junto ao commit, o arquivo rec√©m criado. Se voc√™ quiser ver como est√° o log da branch atual, execute o comando git log.\n  3. Fazendo modifica√ß√µes Em seguida, modifique o arquivo, adicionando uma nova linha com o conte√∫do \u0026ldquo;How are you?\u0026rdquo;. Novamente, execute o comando git add test.txt, mas agora seguido do comando git commit -m 'Second commit' (note que agora o Git n√£o pede mais seu e-mail e nome), e com isso a modifica√ß√£o feita no arquivo ser√° salva pelo git.\n  Agora, se voc√™ rodar o \u0026ldquo;git log\u0026rdquo; novamente, ver√° que h√° um novo registro na lista, correspondente ao segundo commit. Como voc√™ pode ver abaixo:\n  4. Navegando pela branch master Verifique o conte√∫do do arquivo test.txt. experimente agora rodar o comando git checkout master^ (sim, com o acento circunflexo no final), agora, abra novamente o arquivo test.txt no editor. Voc√™ ver√° que o conte√∫do original do primeiro commit foi restaurado.\n  Agora execute git diff master para verificar as diferen√ßas. Ap√≥s fazer esses testes, use git checkout master para restaurar a visualiza√ß√£o para o segundo commit.\n  5. Criando uma branch Agora, vamos experimentar criar uma branch. Para fazer isso, execute o comando git branch nova-branch e ap√≥s isso execute o comando git checkout nova-branch. Para constatar a mudan√ßa de branches, execute o comando git status, que mostra um status geral do reposit√≥rio\n  Nessa nova branch, chamada nova-branch, voc√™ ainda est√° com uma c√≥pia dos commits da branch original master, e ambas as branchs s√£o iguais, pois voc√™ ainda n√£o fez nenhum commit na nova branch. Experimente alterar o arquivo, adicionando uma nova linha com o conte√∫do \u0026ldquo;I\u0026rsquo;m fine\u0026rdquo; e execute os comandos git add test.txt e git commit -m 'Third commit'. Agora, rode o comando git log para ver os commits registrados na branch.\n  6. Mudando de branch Agora, vamos experimentar executar o comando git checkout master para voltar a branch master e ver como est√£o as coisas por l√°. Estando na branch master, execute novamente o comando git log, e constate que o commit \u0026ldquo;Third commit\u0026rdquo; n√£o est√° presente no log (pois afinal esse commit est√° presente apenas na branch nova-branch.\n  Ainda na branch master, experimente criar um arquivo chamado test2.txt com o conte√∫do \u0026ldquo;Hello World 2\u0026rdquo;, adicion√°-lo ao Git executando git add test2.txt e commite a mudan√ßa executando git commit -m 'Fourth commit'\n  Se voc√™ executar o comando \u0026ldquo;git log\u0026rdquo; agora, ver√° que est√£o cadastrados na branch os commits \u0026ldquo;First commit\u0026rdquo;, \u0026ldquo;Second commit\u0026rdquo; e\u0026hellip;.\u0026ldquo;Fourth commit\u0026rdquo;\n  7. Fazendo um merge Agora, vamos juntar o \u0026ldquo;Third Commit\u0026rdquo;, que adiciona mais uma altera√ß√£o no arquivo test.txt e que existe apenas na branch nova-branch - com a branch master, aplicando assim a altera√ß√£o correspondente feita pelo test.txt e mantendo o arquivo test2.txt inalterado.\nPara isso, precisamos fazer o \u0026ldquo;merge\u0026rdquo; das duas branches. Ainda na branch master, execute o comando git merge nova-branch (nesse procedimento, o git vai abrir o merge commit em um editor de texto para voc√™ poder alter√°-lo, apenas salve o arquivo e feche o editor de texto para continuar) e logo em seguida execute o comando git log\n (note que, agora, voc√™ precisa apertar a tecla \u0026ldquo;q\u0026rdquo; para sair da visualiza√ß√£o do comando git log)\n   Um aspecto interessante para voc√™ notar √© que o arquivo test2.txt, criado pelo commit \u0026ldquo;Fourth Commit\u0026rdquo;, foi mantido inalterado pelo merge, pois nenhum commit existente na branch nova-branch altera o arquivo. Al√©m disso, se voc√™ observar bem a ordem dos commits no comando git log, ver√° que o \u0026ldquo;Third Commit\u0026rdquo; aparece antes do \u0026ldquo;Fourth Commit\u0026rdquo;, pois o Git sabe a ordem em que os commits devem ser aplicados.\n8. Visualizando as branch Para terminar o tutorial, execute o comando git log --graph. Ele vai mostrar como o Git entende a ordem dos commits e inclusive uma visualiza√ß√£o bem intuitiva feita em ASCII com a branch nova-branch.\n  Resumo dos comandos praticados  git init - Inicializa um reposit√≥rio git, criando uma pasta oculta chamada \u0026ldquo;.git\u0026rdquo; com os arquivos usados internamente pelo Git; git add [arquivo] - Adiciona as modifica√ß√µes no arquivo (ou pasta) [arquivo] √† \u0026ldquo;staged area\u0026rdquo; do Git, no qual os arquivos que v√£o ser comittados ficam registrados temporariamente. Note que se voc√™ fizer posterior modifica√ß√µes no arquivo, voc√™ ter√° que executar o comando novamente para adicionar as novas modifica√ß√µes √† \u0026ldquo;staged area\u0026rdquo; do Git; git commit -m \u0026quot;[mensagem]\u0026quot; - Registra um commit com as modifica√ß√µes registradas na \u0026ldquo;staged area\u0026rdquo; e com a mensagem \u0026ldquo;[mensagem]\u0026rdquo;, armazenando tamb√©m informa√ß√µes como nome e e-mail do autor do commit a partir das configura√ß√µes salvas anteriormente na base de configura√ß√µes do Git; git config --global user.name \u0026quot;[seu nome]\u0026quot; - Salva o nome \u0026ldquo;[seu nome]\u0026rdquo; na base de configura√ß√µes global do Git; git config --global user.email \u0026quot;[seu e-mail]\u0026quot; - Salva o e-mail \u0026ldquo;[seu e-mail]\u0026rdquo; na base de configura√ß√µes global do Git; git log - Mostra os commits registrados na branch atual; git checkout [alvo] - Faz o Git mudar o ponteiro HEAD (ou seja, o que se refere ao estado atual do reposit√≥rio, que voc√™ v√™) para [alvo], que pode ser o nome de uma branch, o hash de um commit, ou pode ser algumas refer√™ncias especiais, como:  master^ - Muda para o pen√∫ltimo commit da branch master; [branch] - Muda para a branch [branch];   git diff [alvo] - Faz o git mostrar as diferen√ßas entre o commit do ponteiro HEAD (que voc√™ est√° vendo no momento) e [alvo], que pode ser uma branch, o hash de um commit, ou pode ser algumas refer√™ncias especiais (como no caso do git checkout); git branch [branch] - Cria uma nova branch com o nome [branch], copiando todos os commits da branch no qual voc√™ est√° at√© o commit referido pelo ponteiro HEAD; git merge [branch] - \u0026ldquo;Junta\u0026rdquo; a branch atual no qual voc√™ est√° com a branch de nome [branch], criando um merge commit ao final do processo; git log --graph - Mostra os commits registrados na branch atual, mostrando ao lado esquerdo a conex√£o entre um commit e outro.  Refer√™ncias:\n http://fjorgemota.com/git-sistema-de-controle-de-versoes-distribuido/  "
},
{
	"uri": "/tutorials/docker/docker-install/",
	"title": "Docker - Instalac√£o",
	"tags": ["kvm"],
	"description": "Instalando Docker",
	"content": "Requisitos  Ubuntu Linux 18.04 ou superior  Procedimento Instalando docker sudo apt-get remove docker docker-engine docker.io containerd runc sudo apt-get update sudo apt-get install \\  apt-transport-https \\  ca-certificates \\  curl \\  gnupg-agent \\  software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \\  \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs)\\ stable\u0026#34; sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io sudo docker run hello-world     Instalando docker-compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.27.0/docker-compose-$(uname -s)-$(uname -m)\u0026#34; \\  -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose docker-compose --version Dando permiss√µes para seu usuario rodar o comando docker\nsudo usermod -a -G docker $(id -nu) reboot Refer√™ncias  https://docs.docker.com/engine/install/ubuntu/ https://docs.docker.com/compose/install/  "
},
{
	"uri": "/tutorials/git/git-bash-prompt/",
	"title": "Git Bash Prompt",
	"tags": ["git", "bash"],
	"description": "Instalando um git-bash-prompt para melhorar nossa visibilidade no git",
	"content": "Intro Para ter uma melhor visibilidade do que passa em nossos projetos que est√£o versionados quando estamos trabalhando de forma local, podemos usar ferramentas como √© o caso de git-bash-prompt\nInstala√ß√£o Baixar o repositorio contendo o software\ncd ~ git clone https://github.com/jenciso/bash-git-prompt.git .bash-git-prompt --depth=1 Adicionar algumas linhas dentro do arquivo .bashrc\nGIT_PROMPT_ONLY_IN_REPO=0 GIT_PROMPT_THEME=Single_line_Minimalist source ~/.bash-git-prompt/gitprompt.sh    Testando Baixar qualquer repositorio git. Ex: https://github.com/jenciso/node-express-azure e fazemos uma simples modifica√ß√£o\ngit clone https://github.com/jenciso/node-express-azure cd node-express-azure rm README.md Agora podemos ver que estamos na branch master e o shell nos indica que temos um cambio em nosso repositorio.\n   "
},
{
	"uri": "/tutorials/kvm/kvm-install/",
	"title": "KVM - Instalac√£o",
	"tags": ["kvm"],
	"description": "Instalando KVM",
	"content": "Requisitos  Ubuntu Linux 18.04 ou superior  Procedimento Passo 1: Verificar Verificar se nosso sistema suporta hardware virtualization\negrep -c '(vmx|svm)' /proc/cpuinfo  Se a saida √© maior que zero, nosso sistema suporta virtualiza√ß√£o. Esta tudo ok.\n Agora instalar kvm-ok para saber se o servidor pode rodar hardware accelerated KVM\nsudo apt install cpu-checker sudo kvm-ok   Passo 2: Instalar KVM sudo apt update sudo apt install qemu qemu-kvm libvirt-bin bridge-utils virt-manager   Passo 3: Start \u0026amp; enable libvirtd service sudo service libvirtd start sudo update-rc.d libvirtd enable service libvirtd status   Refer√™ncias  https://www.linuxtechi.com/install-configure-kvm-ubuntu-18-04-server/  "
},
{
	"uri": "/tutorials/",
	"title": "üíª Tutoriais",
	"tags": ["Tutoriais"],
	"description": "Tutoriais diversos",
	"content": "Tutoriais Os tutoriais foram classificados por t√≥picos. Todos eles tem como objetivo ser simples e bem praticos.\n"
},
{
	"uri": "/tutorials/git/git-part1/",
	"title": "Git (Parte 1)",
	"tags": ["git"],
	"description": "Tutorial de GIT",
	"content": " Este tutorial esta baseado do seguinte documento: https://githowto.com\n 1. Prerequisitos  Instalar git-bash-prompt seguindo este tutorial Ter uma estacao de trabalho Linux  2. Prepara√ß√£o Configurando nome e endere√ßo de e-mail\ngit config --global user.name \u0026#34;Seu Nome Completo\u0026#34; git config --global user.email \u0026#34;seu_email@sua_empresa.com\u0026#34; Op√ß√µes de Instala√ß√£o: t√©rminos de linhas (Linux):\ngit config --global core.autocrlf input git config --global core.safecrlf warn   3. Criando o projeto git Vamos a criar um reposit√≥rio git \u0026ldquo;hello\u0026rdquo; e uma p√°gina hello.html com o seguinte conte√∫do: \u0026ldquo;Hello, World\u0026rdquo;\nCrie uma p√°gina de \u0026ldquo;Hello, World\u0026rdquo; e inicialize o reposit√≥rio\nmkdir hello \u0026amp;\u0026amp; cd hello echo \u0026#34;Hello, World\u0026#34; \u0026gt; hello.html git init Adicione a p√°gina ao reposit√≥rio:\ngit add hello.html git commit -m \u0026#34;First Commit\u0026#34;   4. Conferindo o status do reposit√≥rio Use o comando git status para checar o estado atual do reposit√≥rio.\ngit status   5. Fazendo modifica√ß√µes Modificar a p√°gina hello.html com o seguinte conte√∫do:\n\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; Conferindo o status:\ngit status   Notar que:\n O git sabe que o arquivo hello.html foi modificado, mas essas modifica√ß√µes ainda n√£o sofreram commit para o reposit√≥rio. A mensagem de status oferece dicas sobre o que fazer em seguida. Se voc√™ quiser adicionar essas modifica√ß√µes para o reposit√≥rio, use git add. Para desfazer as modifica√ß√µes use git checkout.  6. Adicionando modifica√ß√µes ao stage Mande o git adicionar as modifica√ß√µes ao stage. Confira o status\ngit add hello.html git status   Observar:\n Modifica√ß√µes no hello.html foram adicionadas ao stage. Isso quer dizer que o git sabe da modifica√ß√£o, mas n√£o √© permanente no reposit√≥rio. O pr√≥ximo commit incluir√° as modifica√ß√µes que est√£o no stage. Se voc√™ decidir n√£o fazer commit da modifica√ß√£o, o comando status vai te lembrar que voc√™ pode usar o comando git reset para remover essas mudan√ßas do stage.  7. Colocando em stage e fazendo commits Adicionar algo ao stage no git permite que voc√™ continue fazendo modifica√ß√µes no seu diret√≥rio de trabalho e, quando decidir que quer interagir com o controle de vers√£o, permite que guarde as mudan√ßas em pequenos commits.\nPense que voc√™ editou tr√™s arquivos (a. html, b. html e c. html). Depois disso voc√™ tem que fazer commit de todas as modifica√ß√µes para que as mudan√ßas em a.html e b.html sejam um √∫nico commit, enquanto as mudan√ßas em c.html, que n√£o s√£o l√≥gicamente relacionadas com as duas outras mudan√ßas nos outros dois arquivos, sejam enviadas em um commit diferente.\nEm teoria, voc√™ pode fazer o seguinte:\ngit add a.html git add b.html git commit -m \u0026#34;Changes for a and b\u0026#34; git add c.html git commit -m \u0026#34;Unrelated change to c\u0026#34; Separando a adi√ß√£o ao stage e o commit, voc√™ pode customizar o que vai em cada commit.\n8. Fazendo commit das modifica√ß√µes Na hora de executar o comando git commit vamos omitor o uso do flag -m, desta forma entramos na edi√ß√£o interativa de coment√°rios para o commit. O git ira abrir o editor configurado a partir desta lista (em ordem de prioridade)\n Vari√°vel de ambiente GIT_EDITOR Defini√ß√£o de configura√ß√£o core.editor Vari√°vel de ambiente VISUAL Vari√°vel de ambiente EDITOR  No me caso meu editor √© \u0026lsquo;vi\u0026rsquo;. Caso deseje modificar seu editor de forma permanente, edite o arquivo ~/.gitconfig\nLogo de executar o commit, iremos colocar como comentario \u0026ldquo;Added h1 tag\u0026rdquo;\n  9. Modifica√ß√µes, n√£o arquivos O git trabalha com as modifica√ß√µes, n√£o com os arquivos.\n Primeira mudan√ßa: Adicionando tags padr√£o de p√°ginas e executando git add hello.html. O novo conte√∫do para o arquivo: hello.html ser√°:  \u0026lt;html\u0026gt; \u0026lt;body\u0026gt;  \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add hello.html  Segunda mudan√ßa: Adicione os headers do HTML. Agora adicione os headers ( section) na p√°gina  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Agora excute:\ngit status   Note que o arquivo hello.html est√° listado duas vezes no status.\n A primeira mudan√ßa (a adi√ß√£o das tags padr√£o) est√° no stage e pronta para um commit. A segunda mudan√ßa (adi√ß√£o dos headers) n√£o est√° no stage.  Se voc√™ fizesse um commit agora, os headers n√£o teriam sido salvos no reposit√≥rio.\n Commit: Fa√ßa um commit das mudan√ßas que est√£o no stage (as tags padr√£o) e ent√£o confira novamente o status.  git commit -m \u0026#34;Added standard HTML page tags\u0026#34; git status   O comando status diz que o arquivo hello.html tem modifica√ß√µes n√£o gravadas, mas n√£o est√° mais em buffer.\n Adicionando a segunda modifica√ß√£o: Adicione a segunda modifica√ß√£o ao stage, depois execute o comando git status  git add . git status git commit -m \u0026#34;Added HTML header\u0026#34;   10. Hist√≥rico Usaremos o comando git log\ngit log   Hist√≥rico em uma linha:\ngit log --pretty=oneline Controlando a exibi√ß√£o de entradas\ngit log --pretty=oneline --max-count=2 git log --pretty=oneline --since='5 minutes ago' git log --pretty=oneline --until='5 minutes ago' git log --pretty=oneline --author=\u0026lt;your name\u0026gt; git log --pretty=oneline --all Para rever as modifica√ß√µes feitas na √∫ltima semana\ngit log --all --pretty=format:\u0026quot;%h %cd %s (%an)\u0026quot; --since='7 days ago' Um formato bacana\ngit log --pretty=format:\u0026quot;%h %ad | %s%d [%an]\u0026quot; --graph --date=short   Vamos olhar os detalhes:\n \u0026ndash;pretty=\u0026rdquo;\u0026hellip;\u0026rdquo; define o formato da sa√≠da %h √© o hash abreviado do commit %d mostra decora√ß√µes do commit (ex.: head de branches ou tags) %ad √© a data do commit %s √© o coment√°rio %an √© o nome do autor = \u0026ndash;graph fala para o git mostrar a √°rvore de commits no formato de um gr√°fico de ASCII \u0026ndash;date=short mant√©m o formato de data pequeno e simples  Ent√£o, toda vez que voc√™ quiser ver um log, voc√™ ter√° que digitar muito. Felizmente, n√≥s aprenderemos sobre aliases na pr√≥xima li√ß√£o.\n11. Aliases Adicione as seguintes linhas no arquivo ~/.gitconfig\n[alias] co = checkout ci = commit st = status br = branch hist = log --pretty=format:\\\u0026quot;%h %ad | %s%d [%an]\\\u0026quot; --graph --date=short type = cat-file -t dump = cat-file -p Agora execute:\ngit st git hist   12. Usando vers√µes anteriores Conseguindo os hashes das vers√µes anteriores git hist O resultado ser√°:\n  Confira a data do log e encontre o hash do primeiro commit. Voc√™ vai achar ele na √∫ltima linha do git hist Use o c√≥digo (os seus 7 primeiros caracteres s√£o suficientes) no comando abaixo. Depois disso, cheque o conte√∫do do arquivo hello.html.\ngit checkout \u0026lt;hash\u0026gt; cat hello.html   Voltando para a vers√£o mais atual no branch master git checkout master cat hello.html   ‚Äòmaster‚Äô √© o nome do branch padr√£o. Ao entrar em um branch pelo seu nome, voc√™ vai para a sua vers√£o mais atual.\n13. Adicionando tags a vers√µes Vamos chamar a vers√£o atual do nosso programa \u0026ldquo;Hello\u0026rdquo; de vers√£o 1 (v1).\nCriando a tag do primeiro git tag v1 Tags em vers√µes antigas Vamos adicionar uma tag √† vers√£o anterior da nossa atual vers√£o com o nome v1-beta. N√≥s vamos usar a nota√ß√£o ^ indicando ‚Äúo pai de v1‚Äù. Se a nota√ß√£o v1^ gera problemas, tente usar v1~1 para referenciar a mesma vers√£o. Essa nota√ß√£o significa ‚Äúa primeira vers√£o antes de v1‚Äù.\ngit checkout v1^ cat hello.html   Essa √© a vers√£o com as tags \u0026lt;html\u0026gt; e \u0026lt;body\u0026gt;, mas sem \u0026lt;head\u0026gt;. Vamos fazer dessa a vers√£o v1-beta.\ngit tag v1-beta Acessando atrav√©s do nome da tag git checkout v1 git checkout v1-beta   Vendo tags com o comando tag git tag Vendo tags nos logs git hist master --all   Voc√™ pode ver as tags (v1 e v1-beta) listadas no log juntamente com o nome do branch (master). O HEAD mostra o commit em que voc√™ est√° atualmente (v1-beta).\n"
},
{
	"uri": "/tutorials/kvm/",
	"title": "KVM",
	"tags": ["kvm"],
	"description": "Kernel-based Virtual Machine",
	"content": "Kernel-based Virtual Machine Com o KVM podemos criar m√°quinas virtuais de maneira bem simples. O que nos permitir√° criar ambientes de laboratorio numa simples m√°quina Linux\n"
},
{
	"uri": "/artigos/",
	"title": "‚úç Artigos",
	"tags": ["artigos"],
	"description": "Diversos artigos",
	"content": "Artigos Um conjunto de documentos que acrescentaram conhecimento para uso diario\n"
},
{
	"uri": "/tutorials/git/git-part2/",
	"title": "Git (Parte 2)",
	"tags": ["git"],
	"description": "Tutorial de GIT",
	"content": " Este tutorial √© a continua√ß√£o do tutorial Git (Part 1)\n 14. Descartando mudan√ßas locais (antes do stage) Acessando o branch Master Verifique que voc√™ esta no √∫ltimo commit do branch master antes de continuar.\ngit checkout master Mude o hello.html Acontece de voc√™ modificar o arquivo no seu diret√≥rio de trabalho local e √†s vezes querer descartar as mudan√ßas que voc√™ fez commit. √â aqui que o comando checkout vai te ajudar.\nFa√ßa mudan√ßas ao arquivo hello.html na forma de um coment√°rio indesejado.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;!-- This is a bad comment. We want to revert it. --\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Confira o status\ngit status   Desfazendo as mudan√ßas no diret√≥rio de trabalho cat hello.html git checkout hello.html git status cat hello.html   O comando status mostra que n√£o existem mudan√ßas que n√£o est√£o no stage no reposit√≥rio de trabalho. E o ‚Äúcoment√°rio ruim‚Äù n√£o est√° mais no arquivo.\n15. Descartando mudan√ßas no stage (antes do commit) Edite o arquivo e adicione as mudan√ßas ao stage Fa√ßa mudan√ßas ao arquivo hello.html na forma de um coment√°rio indesejado.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- This is an unwanted but staged comment --\u0026gt;  \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; E logo adicione o arquivo ao stage.\ngit add hello.html git status   Revertendo a zona de buffer Felizmente, o status informado nos mostra exatamente o que devemos fazer para cancelar mudan√ßas no stage.\ngit reset HEAD hello.html   O comando reset retorna a zona do buffer para HEAD. Isso limpa a zona do buffer das mudan√ßas que n√≥s acabamos de adicionar ao stage.\nO comando reset (padr√£o) n√£o altera o diret√≥rio de trabalho. Logo, o diret√≥rio de trabalho ainda tem os coment√°rios indesejados. N√≥s podemos usar o comando checkout do tutorial anterior para remover as mudan√ßas do reposit√≥rio de trabalho.\nMudando para a vers√£o do commit git checkout hello.html git status   Nosso diret√≥rio de trabalho est√° limpo novamente.\n16. Desfazendo commits Algumas vezes voc√™ percebe que os novos commits est√£o errados e voc√™ quer desfaz√™-los. Existem v√°rias maneiras de resolver esse problema, mas n√≥s usamos a mais segura aqui.\nPara desfazer o commit, vamos criar um novo commit desfazendo as modifica√ß√µes n√£o desejadas.\nEdite o arquivo e fa√ßa um commit Substitua o arquivo hello.html com o seguinte.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;!-- This is an unwanted but committed change --\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add hello.html git commit -m \u0026quot;Oops, we didn't want this commit\u0026quot; Fa√ßa um commit com as novas modifica√ß√µes que desfazem as modifica√ß√µes anteriores Para desfazer o commit, precisamos criar um commit que deleta as modifica√ß√µes feitas pelo commit indesejado.\ngit revert HEAD   Voce tb poderia haver usado o comando git revert HEAD --no-edit. O comando --no-edit pode ser ignorado. Ele era desnecess√°rio para gerar as informa√ß√µes de sa√≠da sem abrir o editor.\nConfira o log git hist   A seguir vamos olhar a t√©cnica que pode ser usada para remover o √∫ltimo commit do hist√≥rico do reposit√≥rio.\n17. Removendo um commit de um branch Revert √© um comando poderoso da se√ß√£o anterior que te permite cancelar quaisquer commits para um reposit√≥rio. Apesar disso, tanto os commits originais quanto os cancelados permanecem vis√≠veis no hist√≥rico do branch (quando usamos o comando git log).\nFrequentemente depois que um commit √© feito percebemos que ele era um erro. Seria legal ter um comando de desfazer que permitisse deletar o commit incorreto imediatamente. Esse comando preveniria a apari√ß√£o de um commit indesejado no hist√≥rico do git log.\nO comando reset N√≥s j√° usamos o comando reset para equiparar o buffer zone e o commit selecionado (commit HEAD foi usado na li√ß√£o anterior).\nQuando uma refer√™ncia a um commit √© dada (Exemplo: um branch, hash, ou tag name), o comando reset vai\u0026hellip;\n Sobrescrever o branch atual para que ele aponte para o commit correto Opcionalmente resetar o buffer zone para que ele satisfazer o commit especificado Opcionalmente resetar o dir√©torio de trabalho para que ele equipare-se ao commit especificado  Cheque nosso hist√≥rico git hist   N√≥s vemos que os dois √∫ltimos commits desse branch s√£o \u0026ldquo;Oops\u0026rdquo; and \u0026ldquo;Revert Oops\u0026rdquo;. Vamos remov√™-los com o comando reset.\nMarque esse branch primeiro Vamos marcar nosso √∫ltimo commit com tag, para que possamos ach√°-lo ap√≥s remover commits.\ngit tag oops Resete o commit para o Oops anterior No log de hist√≥rico (veja acima), o commit com tag ¬´v1¬ª est√° fazendo commit sobre um commit anterior incorreto. Vamos resetar o branch para aquele ponto. Como o branch tem uma tag, podemos usar o nome da tag no comando reset (se n√£o possuir uma tag, podemos usar o valor hash).\ngit reset --hard v1 git hist   Nada √© perdido para sempre O que acontece com os commits errados? Eles ainda est√£o no reposit√≥rio. Na verdade, ainda podemos nos referir a eles. No in√≠cio da li√ß√£o, criamos a tag ¬´oops¬ª para o commit cancelado. Vamos dar uma olhada em all (todos) commits.\ngit hist --all   Podemos ver que os commits errados n√£o foram embora. Eles n√£o est√£o listados mais no branch master mas ainda permanecem no reposit√≥rio. Eles ainda estariam no reposit√≥rio caso n√£o tiv√©ssemos colocado uma tag neles, mas s√≥ poder√≠amos referenci√°-los por seus nomes hash. Commits n√£o referenciados continuam no reposit√≥rio at√© que um software garbage collection √© acionado pelo sistema.\nPerigos de resetar Resets em branches locais geralmente s√£o inofensivos. As consequ√™ncias de quaisquer \u0026ldquo;acidentes\u0026rdquo; podem ser revertidos usando um commit apropriado.\nApesar disso, outros usu√°rios que compartilham o branch podem ficar confusos se o branch compartilhado fica armazenado em reposit√≥rios remotos.\n18. Removendo a tag oops A tag oops j√° fez o seu trabalho. Vamos remov√™-la e permitir que o garbage collector delete o commit referenciado.\ngit tag -d oops git hist --all   19. Mudando commits Mude a p√°gina e fa√ßa um commit Coloque um coment√°rio de autor na p√°gina.\n\u0026lt;!-- Author: Juan Enciso --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add hello.html git commit -m \u0026quot;Add an author comment\u0026quot; Oops\u0026hellip; precisa do e-mail Depois de fazer o commit, voc√™ percebe que todo bom coment√°rio deveria incluir o e-mail do autor. Edite a p√°gina hello para fornecer um e-mail.\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Mude o commit anterior N√≥s n√£o queremos criar outro commit apenas para o e-mail. Vamos mudar o commit anterior e adicionar o endere√ßo de e-mail.\ngit add hello.html git commit --amend -m \u0026quot;Add an author/email comment\u0026quot;   Olhar o hist√≥rico git hist   O novo commit \u0026ldquo;author/email\u0026rdquo; substitui o commit original \u0026ldquo;author\u0026rdquo;. O mesmo pode ser obtido usando o comando reset no branch e fazendo novamente o commit com as mudan√ßas.\n20. Movendo arquivos Mova o arquivo hello.html para a pasta lib. Agora criaremos a estrutura do nosso reposit√≥rio. Vamos mover a p√°gina no diret√≥rio lib\nmkdir lib git mv hello.html lib git status Movendo arquivos com git, n√≥s notificamos o git sobre duas coisas\n O arquivo hello.html foi deletado. O arquivo lib/hello.html foi criado.  Ambos os fatos v√£o para stage imediatamente e ficam prontos para o commit. O comando git status reporta que o arquivo foi movido.\nMais um jeito de mover arquivos Um fato positivo sobre o git √© que voc√™ n√£o precisa se lembrar de controle de vers√£o no momento em que voc√™ faz o commit do c√≥digo. O que poderia acontecer se n√≥s estiv√©ssemos usando a linha de comando do sistema operacional ao inv√©s do comando git para mover arquivos?\nO pr√≥ximo set de comandos √© id√™ntico √†s nossas √∫ltimas a√ß√µes. √â necess√°rio mais trabalho para o mesmo resultado.\nN√≥s podemos fazer:\nmkdir lib mv hello.html lib git add lib/hello.html git rm hello.html Fa√ßa commit do novo diret√≥rio Vamos fazer commit dessa mudan√ßa.\ngit commit -m \u0026quot;Moved hello.html to lib\u0026quot;   21. Mais informa√ß√£o sobre a estrutura Adicionando index.html Vamos adicionar um arquivo index.html ao nosso reposit√≥rio. O arquivo a seguir √© perfeito para esse prop√≥sito.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026#34;lib/hello.html\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Adicione o arquivo e fa√ßa um commit.\ngit add index.html git commit -m \u0026quot;Added index.html.\u0026quot; Agora quando voc√™ abrir index.html, voc√™ dever√° ver uma parte da p√°gina hello em uma pequena janela.\n  firefox index.html 22. Dentro do Git: diret√≥rio .git O diret√≥rio .git Essa √© uma pasta especial onde todas as coisas do git est√£o. Vamos explorar o diret√≥rio.\n  Banco de Dados de Objetos ls -C .git/objects/\u0026lt;dir\u0026gt; Voc√™ deve ver v√°rias pastas nomeadas com dois caracteres. As duas primeiras letras do hash sha1 do objeto armazenado no git s√£o o nome dos seus diret√≥rios.\nVamos dar uma olhada em uma das pastas nomeadas com dois caracteres. Devem ter arquivos com nomes de 38 caracteres. Esses arquivos cont√©m os objetos armazenados no git. Eles s√£o comprimidos e encriptados, ent√£o √© imposs√≠vel ver seu conte√∫do diretamente. Vamos dar uma olhada melhor no diret√≥rio Git.\n  Arquivo Config cat .git/config   Branches e tags ls .git/refs ls .git/refs/heads ls .git/refs/tags cat .git/refs/tags/v1   Arquivos no subdiret√≥rio de tags devem ser familiares pra voc√™. Cada arquivo corresponde a tag anteriormente criada usando o comando git tag. Seu conte√∫do n√£o √© nada mais que um hash de um commit associado √† tag.\nA pasta heads √© quase id√™ntica e √© usada n√£o para tags, mas para branches. No momento, n√≥s s√≥ temos um branch e tudo que voc√™ v√™ nessa pasta √© um branch master.\nArquivo HEAD cat .git/HEAD   Existe uma refer√™ncia para o branch atual no arquivo HEAD. Nesse momento, ela tem que ser para o branch master.\n23. Dentro do Git: Trabalhando diretamente com objetos do git Procurando pelo √∫ltimo commit git hist --max-count=1   Exibi√ß√£o do √∫ltimo commit Com a hash SHA1, tal como acima\u0026hellip;\ngit cat-file -t \u0026lt;hash\u0026gt; git cat-file -p \u0026lt;hash\u0026gt;   Busca em √°rvore N√≥s podemos exibir a √°rvore referenciada no commit. Isso deveria ser uma descri√ß√£o do arquivo no nosso projeto (para um commit espec√≠fico). Use a hash SHA1 da string da √°rvore listada acima.\ngit cat-file -p \u0026lt;treehash\u0026gt;   Exibir diret√≥rio da lib e Exibir o arquivo hello.html git cat-file -p \u0026lt;libhash\u0026gt; git cat-file -p \u0026lt;hellohash\u0026gt;   E a√≠ est√°. Objetos √°rvores, objetos de commits e objetos blob s√£o exibidos diretamente do reposit√≥rio do git. E isso √© tudo que tem - √°rvores, blobs e commits.\nExplore voc√™ mesmo O reposit√≥rio git pode ser explorado manualmente. Tente achar manualmente o arquivo hello.html original do primeiro commit com ajuda da hash SHA1 referenciada no √∫ltimo commit.\n"
},
{
	"uri": "/tutorials/git/git-part3/",
	"title": "Git (Parte 3)",
	"tags": ["git"],
	"description": "Tutorial de GIT",
	"content": " Este tutorial √© a continua√ß√£o do tutorial Git (Part 2)\n 24. Criando um Branch Vamos nomear o nosso novo branch como ¬´style¬ª.\ngit checkout -b style git status Nota:\n git checkout -b \u0026lt;branch name\u0026gt; √© o atalho de git branch \u0026lt;branch name\u0026gt; seguido por git checkout \u0026lt;branch name\u0026gt; Note que o comando git status avisa que voc√™ est√° no branch style.  Adicione o arquivo style.css touch lib/style.css Arquivo lib/style.css\nh1 { color: red; } Execute:\ngit add lib/style.css git commit -m \u0026#34;Added css stylesheet\u0026#34;   Mude a p√°gina principal Atualize o arquivo lib/hello.html para usar o style.css.\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt;  \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add lib/hello.html git commit -m \u0026quot;Hello uses style.css\u0026quot;   Mude o index.html Atualice o arquivo index.html para que ele use style.css\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;lib/style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026#34;lib/hello.html\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add index.html git commit -m \u0026quot;Updated index.html\u0026quot;   25. Navegando em Branches Agora o seu projeto possui dois branches:\ngit hist --all   Trocando para o branch master git checkout master cat lib/hello.html   Vamos retornar para o branch do style. git checkout style cat lib/hello.html   26. Mudan√ßas no branch master Enquanto voc√™ est√° mudando o branch style, algu√©m decide mexer na branch master. Ele adicionou um arquivo README.md.\nCrie um arquivo README.md\n## Tutorial  This is the Hello World example from the git tutorial. Fa√ßa um commit das mudan√ßas do arquivo README no branch master.\ngit checkout master git add README.md git commit -m \u0026quot;Added README\u0026quot;   27. Visualizando os diferentes branches Agora n√≥s temos um reposit√≥rio com dois branches diferentes. Para ver branches e suas diferen√ßas, use o comando log como segue.\ngit hist --all   N√≥s temos a oportunidade de ver o --graph do git hist em a√ß√£o. Adicionando a op√ß√£o --graph ao git log faz com que ele crie uma √°rvore de commits com a ajuda de caracteres ASCII simples. N√≥s vemos ambos os branches (style e master) e que o branch atual √© o master HEAD. O arquivo index.html adicionado vai antes de ambos branches.\nA flag \u0026ndash;all garante que n√≥s vejamos todos os branches. Por padr√£o, apenas o branch atual √© mostrado.\n28. Merging Merging em um √∫nico branch Merge junta as modifica√ß√µes de dois branches em um. Vamos voltar para o branch style e fazer um merge dele com o master.\ngit checkout style git merge master git hist --all   Pelo merge periodico entre os branches master e style, voc√™ pode acompanhar quaisquer mudan√ßas ou modifica√ß√µes ocorridas para manter a compatibilidade das mudan√ßas de estilo na linha principal.\nPor√©m, isso faz com que os gr√°ficos de commits fiquem feios. Mais tarde vamos considerar a reloca√ß√£o como uma alternativa √† fus√£o.\n29. Criando um conflito Voltar para o master e criar o conflito Volte para o branch master e fa√ßa as seguintes altera√ß√µes:\ngit checkout master Arquivo lib/hello.html\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- no style --\u0026gt;  \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World! Life is great!\u0026lt;/h1\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add lib/hello.html git commit -m 'Life is great!' Visualize os branches\ngit hist --all   Depois de um commit \u0026ldquo;Added README\u0026rdquo; o branch master foi feito um merge com o branch style, mas existe um commit aditional do master, que n√£o foi feito um merge com o branch style.\nA √∫ltima modifica√ß√£o feita no master entra em conflito com algumas mudan√ßas do style. No pr√≥ximo passo n√≥s vamos resolver esse conflito.\n30. Resolvendo conflitos Fazer merge do branch master com o style git checkout style git merge master   A primeira se√ß√£o e a vers√£o do branch atual (style) head. A segunda se√ß√£o √© a vers√£o do branch master.\nResolu√ß√£o do conflito Voc√™ precisa resolver o conflito manualmente. Fa√ßa mudan√ßas no lib/hello.html para alcan√ßar o seguinte resultado.\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World! Life is great!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Merging avan√ßado Git n√£o tem ferramentas gr√°ficas de merging, mas aceita qualquer ferramenta de merge produzida por terceiros. (leia mais sobre essas ferramentas no StackOverflow.)\n31. Realocating como uma alternativa √† merge Vamos olhar para as diferen√ßas entre realocating e merge. Para fazer isso, precisamos voltar no reposit√≥rio no momento antes do primeiro merge e ent√£o repetir os mesmos passos realocando ao inv√©s de fazer merge.\nN√≥s usaremos o comando reset para voltar o branch para um estado anterior.\n32. Resetando o branch style Vamos para o branch style no ponto antes de darmos merge com o branch master. Podemos resetar o branch para qualquer commit. Na verdade, isso faz com que o ponteiro do branch aponte para qualquer commit contido na √°rvore.\nAqui, queremos voltar no style branch para um ponto anterior ao merge com o master. Temos que encontrar o √∫ltimo commit antes do merge\ngit checkout style git hist   √â um pouco dif√≠cil de ler, mas podemos perceber pelos dados que o commit Updated index.html foi o √∫ltimo no branch style anterior ao merging. Vamos resetar o style branch para esse commit.\ngit reset --hard \u0026lt;hash\u0026gt; git hist --all   Agora no branch style n√£o existem commits de merge no nosso hist√≥rico.\n33. Reset do branch master Resetando branch master O modo interativo que adicionamos ao branch master se tornou uma mudan√ßa que conflita com as mudan√ßas do branch style. Vamos reverter as mudan√ßas do branch master para o ponto anterior √† mudan√ßa conflitante. Isso nos permite demonstrar o comando rebase sem nos preocupar com conflitos.\ngit checkout master git hist   O commit \u0026ldquo;Added README\u0026rdquo; est√° imediatamente antes do modo interativo conflitante ser adicionado. Agora precisamos resetar o branch master para o commit \u0026ldquo;Added README\u0026rdquo; .\ngit reset --hard \u0026lt;hash\u0026gt; git hist --all Examine o log. Ele deve parecer como se tiv√©ssemos retrocedido o reposit√≥rio para um ponto no tempo anterior a qualquer merge.\n  34. Rebase Ent√£o n√≥s voltamos no hist√≥rico at√© antes do primeiro merge e queremos realocar as mudan√ßas do master para o nosso branch style.\nDessa vez n√≥s vamos usar o comando rebase ao inv√©s do merge.\ngit checkout style git rebase master git hist   Merge VS Rebase O resultado do comando rebase parece muito com o do merge. O branch style atualmente cont√©m todas as suas mudan√ßas, al√©m das mudan√ßas do branch master. A √°rvore de commits, por√©m, est√° um pouco diferente. A √°rvore de commit do branch style foi reescrita para fazer o branch master parte do hist√≥rico de commits. Isso faz com que a cadeia de commits seja mais linear e leg√≠vel.\nQuando usar rebase, quando usar merge? N√£o use o comando rebase\u0026hellip;\n Se o branch √© p√∫blico e compartilhado. Reescrever tais branches vai atrapalhar o trabalho de outros colegas. Quando o hist√≥rico exato de commits do branch √© importante (porque o comando rebase reescreve o hist√≥rico de commits).  Dadas as recomenda√ß√µes acima, eu prefiro usar rebase para branches locais e de curto prazo e merge para branches em reposit√≥rios p√∫blicos.\n35. Merging com o branch master N√≥s mantivemos nosso branch style atualizado em rela√ß√£o ao branch master (usando rebase), mas agora vamos fazer merge das modifica√ß√µes de volta no master.\ngit checkout master git merge style J√° que o √∫ltimo commit do master √© anterior ao o √∫ltimo commit do branch style, o git consegue fundir em modo de avan√ßo r√°pido - simplesmente movendo o ponteiro do branch para frente, apontando para o mesmo commit que o branch style.\nConflitos n√£o surgem no fast-forward merge.\n  Confira os logs git hist   Agora o style e o master s√£o id√™nticos. Verifique:\ngit hist --all 36. Reposit√≥rios m√∫ltiplos At√© agora s√≥ trabalhamos com um reposit√≥rio git. Apesar disso, git √© √≥timo para trabalhar com v√°rios reposit√≥rios. Os reposit√≥rios adicionais podem ser armazenados localmente ou acessados por conex√£o de rede.\nNa pr√≥xima se√ß√£o iremos criar um novo reposit√≥rio chamado \u0026ldquo;cloned_hello\u0026rdquo;. N√≥s iremos discutir como mover mudan√ßas de um reposit√≥rio para o outro, lidando com conflitos que possam surgir.\nNOTA: N√≥s faremos mudan√ßas em ambas as c√≥pias do nosso reposit√≥rio. Preste aten√ß√£o no reposit√≥rio em que voc√™ est√° em cada est√°gio das pr√≥ximas li√ß√µes.\n37. Clonando reposit√≥rios Se voc√™ est√° trabalhando em grupo, √© importante que voc√™ entenda os pr√≥ximos 12 cap√≠tulos, porque voc√™ geralmente ter√° que trabalhar com reposit√≥rios clonados.\ncd .. pwd git clone hello cloned_hello ls -ld hello cloned_hello   38. Examine o reposit√≥rio clonado Visualizando o hist√≥rico do reposit√≥rio\ncd cloned_hello ls git hist --all   Voc√™ ver√° uma lista de todos os commits no novo reposit√≥rio, que deveriam ser iguais aos do reposit√≥rio original. A √∫nica diferen√ßa deveria ser o nome dos branches.\nBranches remotos Voc√™ ver√° um branch master (HEAD) no hist√≥rico. Voc√™ tamb√©m ver√° branches com nomes estranhos (origin/master, origin/style e origin/HEAD). N√≥s falaremos deles depois.\n39. O que √© origin? git remote git remote show origin   N√≥s podemos ver que o ‚Äúorigin‚Äù do reposit√≥rio remoto √© o reposit√≥rio hello original. Reposit√≥rios remotos s√£o tipicamente guardados em uma m√°quina separada ou em um servidor centralizado. Por√©m, como podemos ver, eles tamb√©m podem apontar para um reposit√≥rio na mesma m√°quina. N√£o tem nada especial sobre o nome ‚Äúorigin‚Äù, mas existe uma conven√ß√£o de us√°-lo para o reposit√≥rio prim√°rio central (se houver algum).\n40. Branches remotos Vamos dar uma olhada nos branches do nosso reposit√≥rio clonado.\ngit branch   Como podemos ver, apenas o branch master est√° listado. Onde est√° o branch style? git branch lista apenas os branches locais, por padr√£o.\nLista dos branches remotos Para ver todos os branches, use o seguinte comando:\ngit branch -a   O Git lista todos os commits do reposit√≥rio original, mas os branches do reposit√≥rio remoto n√£o s√£o tratados como os locais. Se n√≥s precisamos do nosso pr√≥prio branch style, teremos que cri√°-lo. Em um minuto voc√™ ver√° como isso √© feito.\n41. Mudando o reposit√≥rio original Fa√ßa uma mudan√ßa no reposit√≥rio original hello cd ../hello Fa√ßa as seguintes mudan√ßas no arquivo README:\n## Tutorial  This is the Hello World example from the git tutorial. (changed in original) Agora adicione e fa√ßa commit dessas mudan√ßas\ngit add README git commit -m \u0026quot;Changed README in original repo\u0026quot;   Agora o reposit√≥rio original tem mudan√ßas mais recentes que n√£o est√£o inclu√≠das na vers√£o clonada. Em seguida, vamos receber essas mudan√ßas no reposit√≥rio clonado.\n42. Trazendo modifica√ß√µes cd ../cloned_hello git fetch git hist --all   Neste momento, o reposit√≥rio cont√©m todos os commits do reposit√≥rio original. Por√©m, eles n√£o est√£o integrados com os branchs locais do reposit√≥rio clonado.\nVoc√™ vai ver o commit de nome ‚ÄúChanged README in original repo‚Äù no hist√≥rico. Perceba que o commit inclui ‚Äúorigin/master‚Äù e ‚Äúorigin/HEAD‚Äù.\nAgora vamos dar uma olhada no commit ‚ÄúUpdated index.html‚Äù. Voc√™ vai ver que o branch master local aponta para esse commit, n√£o para o commit que acabamos de trazer.\nIsso nos mostra que o comando ‚Äúgit fetch‚Äù vai trazer os novos commits do reposit√≥rio remoto, mas n√£o vai fundir eles com os branches locais.\nCheque o README N√≥s podemos mostrar que o arquivo README clonado n√£o foi modificado.\ncat README.md   43. Merging as modifica√ß√µes baixadas Fa√ßa merge das modifica√ß√µes baixadas no branch master local e agora voc√™ deve ver as modifica√ß√µes no arquivo README.md\ngit merge origin/master cat README.md   44. Fazendo pull e merge de modifica√ß√µes N√£o iremos passar por todo o processo de fazer e dar pull em uma mudan√ßa, mas queremos que voc√™s saibam que:\ngit pull √©, na verdade, equivalente a fazer os seguintes passos:\ngit fetch git merge origin/master 45. Adicionando um branch de rastreamento Branches que come√ßam com remotes/origin pertencem ao reposit√≥rio original. Perceba que, mesmo que voc√™ n√£o tenha mais o branch styles, ele sabe que o branch est√° no reposit√≥rio original.\nAdicione um branch local que rastreia um branch remoto. git branch --track style origin/style git branch -a git hist --max-count=2   46. Reposit√≥rios bare Reposit√≥rios bare (sem o diret√≥rio de trabalho) s√£o tipicamente usados para compartilhamento.\nCriando um reposit√≥rio bare cd .. git clone --bare hello hello.git ls -ld hello.git cd hello.git/ ls -l Tipicamente, reposit√≥rios terminados em .git s√£o bare. Como voc√™ pode ver, n√£o existe nenhum diret√≥rio de trabalho no reposit√≥rio hello.git. Na verdade, ele n√£o √© nada mais que o diret√≥rio .git de um reposit√≥rio que n√£o √© bare.\n  47. Adicionando um reposit√≥rio remoto Vamos adicionar o reposit√≥rio hello.git ao nosso reposit√≥rio original.\ncd .. cd hello git remote add shared ../hello.git   NOTA: N√≥s estamos agora no reposit√≥rio hello.\n48. Submetendo modifica√ß√µes A partir de um reposit√≥rio limpo, geralmente compartilhado em qualquer servidor de rede, precisamos enviar nossas modifica√ß√µes a outros reposit√≥rios. Comece criando uma modifica√ß√£o para ser enviada. Edite o arquivo README.md e fa√ßa um commit\n## Tutorial  This is the Hello World example from the git tutorial. (Changed in original and pushed to shared) git checkout master git add README git commit -m \u0026quot;Added shared comment to readme\u0026quot;   Agora envie as modifica√ß√µes para o reposit√≥rio compartilhado.\ngit push shared master O reposit√≥rio comum est√° recebendo nossas modifica√ß√µes enviadas. (Lembre-se, n√≥s adicionamos ele como um reposit√≥rio remoto na li√ß√£o anterior).\n  Nota: Tivemos que explicitamente especificar o branch master para submeter as mudan√ßas. Isso pode ser configurado automaticamente, mas eu sempre esque√ßo o comando. Para f√°cil administra√ß√£o de seus branches remotos mude para ¬´Git Remote Branch¬ª.\n49. Removendo modifica√ß√µes comuns Rapidamente mude para o reposit√≥rio clonado e extraia as modifica√ß√µes rec√©m enviadas ao reposit√≥rio comum.\ncd ../cloned_hello Nota: Estamos agora no reposit√≥rio cloned_hello.\nContinue com \u0026hellip;\ngit remote add shared ../hello.git git branch --track shared master git pull shared master cat README.md   50. Divulgando o seu reposit√≥rio Existem maneiras diferentes de compartilhar um reposit√≥rio git na rede. Essa √© a mais r√°pida.\nExecute git server cd .. git daemon --verbose --export-all --base-path=.   Agora, v√° ao seu diret√≥rio de trabalho num terminal separado.\ngit clone git://localhost/hello.git network_hello cd network_hello ls   Confira se seu vizinho usa git daemon. Troquem seus endere√ßos IP e depois confiram se voc√™s podem pegar as altera√ß√µes dos reposit√≥rios um do outro.\n"
},
{
	"uri": "/",
	"title": "Docs Planet",
	"tags": [],
	"description": "",
	"content": "Docs Planet O Docs Planet √© um repostitorio de conte√∫do de tutoriais sobre tecnologias usadas no mundo DevOps\n"
},
{
	"uri": "/tags/git/",
	"title": "git",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/articles/",
	"title": "articles",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/artigos/",
	"title": "artigos",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/bash/",
	"title": "bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/artigos/init-config/",
	"title": "Configura√ß√µes iniciais",
	"tags": ["init"],
	"description": "Primeiros passos para configurar sua estacao de trabalho",
	"content": "Configura√ß√£o de Sudoers Use sudo sem precisar digitar a senha\necho \u0026quot;`whoami` ALL=(ALL) NOPASSWD:ALL\u0026quot; | sudo tee /etc/sudoers.d/admins Criando par de chaves ssh ssh-keygen   "
},
{
	"uri": "/credits/",
	"title": "Credits",
	"tags": [],
	"description": "Contribuidores do Developer Portal",
	"content": "Contribuidores Juan Enciso @jenciso\nMateus Abdala @MateusAbdala\n "
},
{
	"uri": "/tutorials/docker/",
	"title": "Docker",
	"tags": ["docker"],
	"description": "Conte√∫do sobre containers e o mundo Docker",
	"content": "Containers "
},
{
	"uri": "/tags/docker/",
	"title": "docker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tutorials/git/gitflow/",
	"title": "Gitflow",
	"tags": ["git", "gitflow"],
	"description": "Tutorial de Gitflow",
	"content": "Intro Gitflow √© um modelo de organiza√ß√£o de branches criado por Vincent Driessen, N√£o √© o √∫nico modelo de organiza√ß√£o de branches, mas sem d√∫vida √© um dos mais usados.\nNomenclatura Gitflow estabelece algumas regras de nomenclaturas para tipos de branches enquanto, ao mesmo tempo, define o que cada tipo de branch faz. Para refer√™ncia, segue uma lista dos tipos de branches definidos pelo Git Flow e suas respectivas descri√ß√µes:\n  Branch master - √â a branch que cont√©m c√≥digo em n√≠vel de produ√ß√£o, ou seja, o c√≥digo mais maduro existente na sua aplica√ß√£o. Todo o c√≥digo novo produzido eventualmente √© juntado com a branch master, em algum momento do desenvolvimento;\n  Branch develop - √â a branch que cont√©m c√≥digo em n√≠vel preparat√≥rio para o pr√≥ximo deploy. Ou seja, quando features s√£o terminadas, elas s√£o juntadas com a branch develop, testadas (em conjunto, no caso de mais de uma feature), e somente depois as atualiza√ß√µes da branch develop passam por mais um processo para ent√£o ser juntadas com a branch master;\n  Branches feature/[*] - S√£o branches no qual s√£o desenvolvidos recursos novos para o projeto em quest√£o. Essas branches tem por conven√ß√£o nome come√ßando com feature/ (exemplo: feature/new-layout) e s√£o criadas a partir da branch develop (pois um recurso pode depender diretamente de outro recurso em algumas situa√ß√µes), e, ao final, s√£o juntadas com a branch develop;\n  Branches hotfix/[*] - S√£o branches no qual s√£o realizadas corre√ß√µes de bugs cr√≠ticos encontrados em ambiente de produ√ß√£o, e que por isso s√£o criadas a partir da branch master, e s√£o juntadas diretamente com a branch master e com a branch develop (pois os pr√≥ximos deploys tamb√©m devem receber corre√ß√µes de bugs cr√≠ticos, certo?). Por conven√ß√£o, essas branches tem o nome come√ßando com hotfix/ e terminando com o pr√≥ximo sub-n√∫mero de vers√£o (exemplo: hotfix/2.1.1), normalmente seguindo as regras de algum padr√£o de versionamento, como semversion.\n  Branches release/[*] - S√£o branches com um n√≠vel de confian√ßa maior do que a branch develop, e que se encontram em n√≠vel de prepara√ß√£o para ser juntada com a branch master e com a branch develop (para caso tenha ocorrido alguma corre√ß√£o de bug na branch release/* em quest√£o). Note que, nessas branches, bugs encontrados durante os testes das features que v√£o para produ√ß√£o podem ser corrigidos mais tranquilamente, antes de irem efetivamente para produ√ß√£o. Por conven√ß√£o, essas branches tem o nome come√ßando com release/ e terminando com o n√∫mero da pr√≥xima vers√£o do software (seguindo o exemplo do hotfix, dado acima, seria algo como release/2.2.0), normalmente seguindo as regras do versionamento sem√¢ntico.\n  Um aspecto interessante do Git Flow √© que, quando voc√™ mistura uma branch release/ ou hotfix/ com a branch master, ele automaticamente cria git tags correspondentes aos merge commits da mistura, facilitando o trabalho de, por exemplo, mudar para uma vers√£o mais antiga, e organizando todo o trabalho.\nTutorial b√°sico de git flow Para esse tutorial b√°sico de git flow, vou assumir que voc√™ est√° com o reposit√≥rio criado no tutorial basico de git\n1. Instalac√£o Gitflow √© uma extens√£o ao Git, para instalar ele, simplesmente execute sudo apt-get install git-flow\n  2. Inicializando git-flow Agora, na pasta do reposit√≥rio criado no tutorial b√°sico de git, execute os comandos para deixar o repositorio somente com a branch master\ngit branch -a git branch -d nova-branch Logo inicializamos o git flow:\ngit flow init -d  A opc√£o -d, permite configurar o git flow com os nomes default\n   Note que, durante a execu√ß√£o do comando, o Git Flow criar√° a branch develop e far√° git checkout autom√°tico para esta branch.\n3. Criando uma feature branch Agora, vamos criar uma nova feature branch? Para fazer isso, execute o comando:\ngit flow feature start recurso-milionario Aquilo ir√° criar uma nova feature branch chamada recurso-milionario, com o nome feature/recurso-milionario. Antes vamos explorar quais sao as branch q foram criadas:\n  4. Trabalhando na feature branch Nesta nova branch criaremos um arquivo recurso.txt com o conte√∫do \u0026ldquo;Este √© o melhor recurso criado desde sempre!\u0026rdquo;. Logo executaremos os comandos \u0026ldquo;git add recurso.txt\u0026rdquo; e \u0026ldquo;git commit -m \u0026lsquo;Finished feature\u0026rsquo;\u0026rdquo; para adicionar e commitar o arquivo em quest√£o na feature branch recurso-milionario\necho \u0026#39;Este √© o melhor recurso criado desde sempre!\u0026#39; \u0026gt; recurso.txt git add recurso.txt git commit -m \u0026#39;Finished feature\u0026#39;   5. Finalizando os trabalhos na feature branch Com o commit feito, podemos finalmente junt√°-lo a branch develop. Para fazer isso, execute o comando\ngit flow feature finish recurso-milionario   Como voc√™ pode ver, a branch feature/recurso-milionario foi correspondentemente integrada √† branch develop e o git flow fez checkout autom√°tico para a branch develop, te mostrando todos os passos feitos.\n6. Criando uma release branch Agora que temos na branch develop os cambios que queriamos ter, vamos criar uma release branch para poder enfim publicar a atualiza√ß√£o na branch master. Para fazer isso, execute o comando\ngit flow release start 0.1.0   7. Alterando a release branch Agora, com a release branch criada, vamos apenas fazer uma pequena altera√ß√£o no arquivo recurso.txt, modificando a frase:\nDe: \u0026ldquo;Este √© o melhor recurso criado desde sempre!\u0026rdquo;\nPara: \u0026ldquo;Este talvez seja o melhor recurso criado desde sempre!\u0026rdquo;\nLogo commitaremos a mudan√ßa\ngit add recurso.txt git commit -m \u0026#39;Little bug-fix in feature\u0026#39;   Mudan√ßas podem ser feitas antes da branch ser juntada com a branch master\n8. Finalizando a release Com a mudan√ßa registrada, vamos enfim juntar a release branch 0.1.0 com a branch master e a branch develop, para isso, vamos usar o comando\ngit flow release finish 0.1.0 Aquilo vai integrar a mudan√ßa feita √† release branch 0.1.0 com as branches master e develop\n  Como voc√™ pode ver acima, o Git Flow abre o editor de texto tr√™s vezes:\n  Uma para voc√™ editar o texto do merge commit relacionado ao merge entre a release branch 0.1.0 e a branch master\n  Um para a descri√ß√£o da tag 0.1.0, que ser√° criada pelo Git Flow para facilitar mudan√ßas de vers√£o no software\n  Uma para voc√™ editar o texto do merge commit relacionado ao merge entre a branch master e a branch develop\n  9. Criando um hotfix Agora suponhamos que foi encontrado um bug hiper-critico na aplica√ß√£o (coincidentemente, nesse exemplo, suponhamos que foi no mesmo recurso rec√©m adicionado) e que ele √© t√£o grave que est√° afetando o uso por todos os usu√°rios da aplica√ß√£o e por isso precisa ser corrigido com urg√™ncia m√°xima.\nPara corrigir esse bug critico, vamos criar um hotfix usando o comando\ngit flow hotfix start 0.1.1 Aquilo criar√° uma hotfix branch chamada 0.1.1 que resolve um problema encontrado no release 0.1.0\n  10. Corrigindo na branch hotfix Agora que temos a nossa hotfix branch 0.1.1 criada, vamos editar o arquivo recurso.txt com a corre√ß√£o que queremos aplicar, substituindo a frase:\n\u0026ldquo;Este talvez seja o melhor recurso criado desde sempre!\u0026rdquo;, Para:\n\u0026ldquo;Este talvez n√£o seja o melhor recurso criado desde sempre! Mas √© um dos mais legais!\u0026rdquo;\nno arquivo recurso.txt. Logo comitaremos este cambio:\n  11. Finalizando o hotfix Com o \u0026ldquo;bug\u0026rdquo; corrigido e comittado, podemos agora finalizar nossa hotfix branch e com isso junt√°-la √† branch master e √† branch develop. Para fazer isso, basta usar o comando\ngit flow hotfix finish 0.1.1 Aquilo far√° todas essas tarefas por n√≥s e ainda criar√° uma tag para marcar a corre√ß√£o\n  Novamente, como no caso do git flow release finish, estudado acima, o git flow abre o editor tr√™s vezes: Uma para editar o merge commit para o merge com a branch master, outra para editar a descri√ß√£o da tag que ser√° criada pelo Git Flow, e outra para o merge commit para o merge da branch master com a branch develop.\nConclus√µes O Gitflow √© um modelo de organiza√ß√£o de branches √© ideal para trabalhar com projetos em equipe, pois permite que cada membro da equipe trabalhe em cada feature branch com maestria e ainda resolva bugs importantes quando eles forem encontrados.\nRefer√™ncias  http://github.com/nvie/gitflow  "
},
{
	"uri": "/tags/gitflow/",
	"title": "gitflow",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/init/",
	"title": "init",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/kvm/",
	"title": "kvm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tutorials/kvm/kvm-bridge/",
	"title": "KVM - Bridge Setup",
	"tags": ["kvm"],
	"description": "Configurando KVM em modo bridge",
	"content": "Requisitos  KVM instalado Ter uma interfaz de rede ethernet (n√£o wireless) Ubuntu 18.04 ou superior  Procedimento Verificando qual √© o nome da minha interfaz de rede\nnmcli device status  Observe o resultado da columna DEVICE\n Com esse dado configuramos via netplan a configura√ß√£o bridge adicionando um arquivo yaml.\nsudo vi /etc/netplan/50-cloud-init.yaml Copiar um conte√∫do similar. No me caso o DEVICE da minha NIC √© enp2s0:\nnetwork: version: 2 ethernets: enp2s0:  dhcp4: yes dhcp6: no bridges: br0: interfaces: [enp2s0]  dhcp4: yes dhcp6: no Logo aplicamos os cambios:\nsudo netplan apply sudo networkctl status -a Aqui podemos reiniciar nosso computador para poder verificar que as configura√ß√µes persistem.\nsudo reboot Refer√™ncias  https://netplan.io/examples/ https://webby.land/2018/04/27/bridging-under-ubuntu-18-04/ https://github.com/jenciso/notes/blob/master/KVM.md https://askubuntu.com/questions/1106766/netplan-wireless-bridge-ubuntu-18 https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/  "
},
{
	"uri": "/tutorials/kvm/kvm-provision/",
	"title": "KVM - Provision",
	"tags": ["kvm"],
	"description": "Provisionando maquinas virtuais de maneira simples",
	"content": "Requisitos  KVM instalado Ubuntu 18.04 ou superior Usar uma conta com privilegios de root (sudo)  Instala√ß√£o cd ~ git clone https://github.com/jenciso/kvm-provision Prepara√ß√£o Precisamos baixar uma imagem base para poder usar na criaca√ß√£o de VM\u0026rsquo;s. Usaremos a image Centos 7 ja preperada para trabalhar com cloud-init. Colocaremos esta imagem na pasta boot do libvirt. Execute o seguinte comando:\nsudo curl -fSL -C - http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2 \\  -o /var/lib/libvirt/boot/CentOS-7-x86_64-GenericCloud.qcow2 Para poder executar alguns comandos do kvm, precisamos adicionar nosso usuario ao grupo libvirt, e para que os cambios sejam efetivados temos q sair da sessao e volver ingressar\nsudo usermod -a -G libvirt `whoami` logout Come√ßando Criando uma VM (Virtual Machine)\n./new-vm.sh centos7  Esta VM ir√° ter a IP: 192.168.122.10. O user √© centos e o password ser√° SuperSecret2012.  Entrando na VM via console:\nsudo virsh console centos7  Para sair use: Ctrl + ]\n Entrando via SSH\nssh centos@192.168.122.10 Apagando a VM\n./del-vm.sh centos7  Apaga a VM e todo seu conte√∫do, inclusive os discos duros\n Mais comandos Copiando suas Chaves SSH Nossa chave SSH publica pode ser colocada no parametro SSH_KEY_0, de tal maneira que consigamos acessar ao servidor virtual sem precisar user/password.\nSe ainda n√£o criou um par de chaves ssh para seu usuario, siga este procedimento. Logo disso, voce ira ter o arquivo ~/.ssh/id_rsa.pub. Copie e cole o conte√∫do desse arquivo dentro do arquivo config.conf exatamente como o valor da variavel SSH_KEY_0.\nSSH_KEY_0=ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDYN0xPPa9KV0pZ5vNyet5e5fvWHNCgOTJ5ON9SHef3d Criando uma VM com uma configura√ß√£o espec√≠fica Crie a VM demo01 com 1GB de RAM, 2 VCPUs e com a IP 192.168.122.12\n./new-vm.sh -n demo01 -m 1024 -c 2 -i 192.168.122.12 Usando um novo password para suas VM\u0026rsquo;s Cambiando o password default para este valor: MySuperPassword, precisamos executar o comando:\nopenssl passwd -1 -salt SaltSalt MySuperPassword Com a saida desse comando, defina a variavel PASSWORD:\nPASSWORD='$1$SaltSalt$jjGsH9DHuY/4Vda.6JZVH1'\n Dessa forma, a proxima VM ira ter o password MySuperPassword para o user centos\n Aumentando o tamanho do disco duro √â s√≥ editar a variavel:\nDISK_SIZE=40G\n Aquilo ira criar uma VM com 40GB de espaco de disco\n Adicionando um novo disco Caso a VM tenha como nome centos7 e queramos ter um novo disco adicional de 60GB.\n./add-disk.sh -n centos7 -d vdb -s 60G Listar todas as VM\u0026rsquo;s criadas virsh list --all Gestione as VM\u0026rsquo;s em modo grafico virt-manager Ira carregar o seguinte gestor de VMs\n Demo   Referencias  http://blog.programster.org/kvm-creating-thinly-provisioned-guests  "
},
{
	"uri": "/artigos/semversion/",
	"title": "Semantic Version",
	"tags": ["semversion"],
	"description": "Versionamento Semantico",
	"content": "Intro O versionamento sem√¢ntico hoje √© um dos padr√µes de versionamento mais usados e conhecidos.\nTem o objetivo de evitar que atualiza√ß√µes de depend√™ncia quebrem o seu software indevidamente, enquanto permitindo que voc√™ tenha uma no√ß√£o do status de estabilidade do software (se √© \u0026ldquo;seguro\u0026rdquo; usar em produ√ß√£o, por exemplo) e possa identificar se uma nova vers√£o possui apenas novos recursos ou se possui apenas corre√ß√µes de bugs, por exemplo.\nRegras Todo padr√£o tem regras, e com o versionamento sem√¢ntico n√£o poderia ser diferente. Existem 11 regras bem definidas e documentadas no site oficial\nMas o que √© Semantic Version? "
},
{
	"uri": "/tags/semversion/",
	"title": "semversion",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/tutoriais/",
	"title": "Tutoriais",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/links/",
	"title": "üìë Links",
	"tags": ["artigos", "articles"],
	"description": "Material coletado no dia a dia",
	"content": "Git Artigos  https://www.hostinger.com.br/tutoriais/git-branch/ https://www.xpertup.com/blog/technology/git-and-github-fundamentals/ https://dev.to/usmslm102/git-cheat-sheet-4f5a  Git Tutoriais  https://www.atlassian.com/git/tutorials https://try.github.io/ https://www.vogella.com/tutorials/Git/article.html  Git Merge  https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1  Gitflow  https://medium.com/@olivier.bossel/git-flow-the-right-way-to-go-f2a65c315818  Docker Tutoriais  https://www.docker.com/101-tutorial https://docker-curriculum.com/ https://www.ionos.es/digitalguide/servidores/configuracion/tutorial-docker-instalacion-y-primeros-pasos/  CORS  https://dev.to/lydiahallie/cs-visualized-cors-5b8h  "
}]