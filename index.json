[
{
	"uri": "/tutorials/git/",
	"title": "Git",
	"tags": ["git"],
	"description": "Conteudo relacionado a Git",
	"content": "GIT O Git é uma ferramenta de controle de versões ampliamente reconhecida como um standard no mundo TI.\n"
},
{
	"uri": "/tutorials/git/git-basico/",
	"title": "Tutorial - Git Básico",
	"tags": ["git"],
	"description": "Tutorial de GIT Básico",
	"content": "Intro Nesse tutorial, vamos fazer operações básicas relacionadas ao Git. como initializar um repositório, adicionar arquivos, comittar as mudanças, depois modificar os arquivos, adicionar os arquivos modificados, comittar tudo de novo, e por fim algumas noções básicas relacionadas a branch e merges.\nPrerequisitos  Ter o git instalado, senão rodar: sudo apt-get install git Instalar git-bash-prompt seguindo este tutorial Ter uma estacao de trabalho Linux  1. Inicializando o repositorio Crie uma pasta chamada tutorial-git. Entre nela e rode o comando git init\ncd ~ mkdir projetos cd projetos mkdir tutorial-git cd tutorial-git git init   2. Primeiro commit Agora, experimente criar um arquivo chamado test.txt, com uma única linha contendo Hello World. Em seguida, execute o comando git add test.txt seguido de git commit -m 'First commit'.\nComo esse é o seu primeiro commit e o Git não sabe nada sobre você, é necessário adicionar algumas informações (o Git emitirá um erro sempre que você tentar comittar sem essas informações devidamente registradas), como nome e e-mail, para que o Git saiba quem está fazendo o commit e poder registrar essa informação no repositório.\nPara ajustar isso, execute o comando git config --global user.name '[seu nome]' para configurar o seu nome (substitua [seu nome] pelo seu nome nesse comando) e git config --global user.email '[seu e-mail]' para configurar o seu e-mail (substitua [seu e-mail] pelo seu e-mail nesse comando)\nApós executar esses dois comandos, execute novamente o comando git commit -m 'First commit'. Agora sim, seu primeiro commit estará registrado!\n  Note que o Git registrará, junto ao commit, o arquivo recém criado. Se você quiser ver como está o log da branch atual, execute o comando git log.\n  3. Fazendo modificações Em seguida, modifique o arquivo, adicionando uma nova linha com o conteúdo \u0026ldquo;How are you?\u0026rdquo;. Novamente, execute o comando git add test.txt, mas agora seguido do comando git commit -m 'Second commit' (note que agora o Git não pede mais seu e-mail e nome), e com isso a modificação feita no arquivo será salva pelo git.\n  Agora, se você rodar o \u0026ldquo;git log\u0026rdquo; novamente, verá que há um novo registro na lista, correspondente ao segundo commit. Como você pode ver abaixo:\n  4. Navegando pela branch master Verifique o conteúdo do arquivo test.txt. experimente agora rodar o comando git checkout master^ (sim, com o acento circunflexo no final), agora, abra novamente o arquivo test.txt no editor. Você verá que o conteúdo original do primeiro commit foi restaurado.\n  Agora execute git diff master para verificar as diferenças. Após fazer esses testes, use git checkout master para restaurar a visualização para o segundo commit.\n  5. Criando uma branch Agora, vamos experimentar criar uma branch. Para fazer isso, execute o comando git branch nova-branch e após isso execute o comando git checkout nova-branch. Para constatar a mudança de branches, execute o comando git status, que mostra um status geral do repositório\n  Nessa nova branch, chamada nova-branch, você ainda está com uma cópia dos commits da branch original master, e ambas as branchs são iguais, pois você ainda não fez nenhum commit na nova branch. Experimente alterar o arquivo, adicionando uma nova linha com o conteúdo \u0026ldquo;I\u0026rsquo;m fine\u0026rdquo; e execute os comandos git add test.txt e git commit -m 'Third commit'. Agora, rode o comando git log para ver os commits registrados na branch.\n  6. Mudando de branch Agora, vamos experimentar executar o comando git checkout master para voltar a branch master e ver como estão as coisas por lá. Estando na branch master, execute novamente o comando git log, e constate que o commit \u0026ldquo;Third commit\u0026rdquo; não está presente no log (pois afinal esse commit está presente apenas na branch nova-branch.\n  Ainda na branch master, experimente criar um arquivo chamado test2.txt com o conteúdo \u0026ldquo;Hello World 2\u0026rdquo;, adicioná-lo ao Git executando git add test2.txt e commite a mudança executando git commit -m 'Fourth commit'\n  Se você executar o comando \u0026ldquo;git log\u0026rdquo; agora, verá que estão cadastrados na branch os commits \u0026ldquo;First commit\u0026rdquo;, \u0026ldquo;Second commit\u0026rdquo; e\u0026hellip;.\u0026ldquo;Fourth commit\u0026rdquo;\n  7. Fazendo um merge Agora, vamos juntar o \u0026ldquo;Third Commit\u0026rdquo;, que adiciona mais uma alteração no arquivo test.txt e que existe apenas na branch nova-branch - com a branch master, aplicando assim a alteração correspondente feita pelo test.txt e mantendo o arquivo test2.txt inalterado.\nPara isso, precisamos fazer o \u0026ldquo;merge\u0026rdquo; das duas branches. Ainda na branch master, execute o comando git merge nova-branch (nesse procedimento, o git vai abrir o merge commit em um editor de texto para você poder alterá-lo, apenas salve o arquivo e feche o editor de texto para continuar) e logo em seguida execute o comando git log\n (note que, agora, você precisa apertar a tecla \u0026ldquo;q\u0026rdquo; para sair da visualização do comando git log)\n   Um aspecto interessante para você notar é que o arquivo test2.txt, criado pelo commit \u0026ldquo;Fourth Commit\u0026rdquo;, foi mantido inalterado pelo merge, pois nenhum commit existente na branch nova-branch altera o arquivo. Além disso, se você observar bem a ordem dos commits no comando git log, verá que o \u0026ldquo;Third Commit\u0026rdquo; aparece antes do \u0026ldquo;Fourth Commit\u0026rdquo;, pois o Git sabe a ordem em que os commits devem ser aplicados.\n8. Visualizando as branch Para terminar o tutorial, execute o comando git log --graph. Ele vai mostrar como o Git entende a ordem dos commits e inclusive uma visualização bem intuitiva feita em ASCII com a branch nova-branch.\n  Resumo dos comandos praticados  git init - Inicializa um repositório git, criando uma pasta oculta chamada \u0026ldquo;.git\u0026rdquo; com os arquivos usados internamente pelo Git; git add [arquivo] - Adiciona as modificações no arquivo (ou pasta) [arquivo] à \u0026ldquo;staged area\u0026rdquo; do Git, no qual os arquivos que vão ser comittados ficam registrados temporariamente. Note que se você fizer posterior modificações no arquivo, você terá que executar o comando novamente para adicionar as novas modificações à \u0026ldquo;staged area\u0026rdquo; do Git; git commit -m \u0026quot;[mensagem]\u0026quot; - Registra um commit com as modificações registradas na \u0026ldquo;staged area\u0026rdquo; e com a mensagem \u0026ldquo;[mensagem]\u0026rdquo;, armazenando também informações como nome e e-mail do autor do commit a partir das configurações salvas anteriormente na base de configurações do Git; git config --global user.name \u0026quot;[seu nome]\u0026quot; - Salva o nome \u0026ldquo;[seu nome]\u0026rdquo; na base de configurações global do Git; git config --global user.email \u0026quot;[seu e-mail]\u0026quot; - Salva o e-mail \u0026ldquo;[seu e-mail]\u0026rdquo; na base de configurações global do Git; git log - Mostra os commits registrados na branch atual; git checkout [alvo] - Faz o Git mudar o ponteiro HEAD (ou seja, o que se refere ao estado atual do repositório, que você vê) para [alvo], que pode ser o nome de uma branch, o hash de um commit, ou pode ser algumas referências especiais, como:  master^ - Muda para o penúltimo commit da branch master; [branch] - Muda para a branch [branch];   git diff [alvo] - Faz o git mostrar as diferenças entre o commit do ponteiro HEAD (que você está vendo no momento) e [alvo], que pode ser uma branch, o hash de um commit, ou pode ser algumas referências especiais (como no caso do git checkout); git branch [branch] - Cria uma nova branch com o nome [branch], copiando todos os commits da branch no qual você está até o commit referido pelo ponteiro HEAD; git merge [branch] - \u0026ldquo;Junta\u0026rdquo; a branch atual no qual você está com a branch de nome [branch], criando um merge commit ao final do processo; git log --graph - Mostra os commits registrados na branch atual, mostrando ao lado esquerdo a conexão entre um commit e outro.  Referências:\n http://fjorgemota.com/git-sistema-de-controle-de-versoes-distribuido/  "
},
{
	"uri": "/tutorials/docker/docker-install/",
	"title": "Docker - Instalacão",
	"tags": ["kvm"],
	"description": "Instalando Docker",
	"content": "Requisitos  Ubuntu Linux 18.04 ou superior  Procedimento Instalando docker sudo apt-get remove docker docker-engine docker.io containerd runc sudo apt-get update sudo apt-get install \\  apt-transport-https \\  ca-certificates \\  curl \\  gnupg-agent \\  software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository \\  \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs)\\ stable\u0026#34; sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io sudo docker run hello-world     Instalando docker-compose sudo curl -L \u0026#34;https://github.com/docker/compose/releases/download/1.27.0/docker-compose-$(uname -s)-$(uname -m)\u0026#34; \\  -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose docker-compose --version Dando permissões para seu usuario rodar o comando docker\nsudo usermod -a -G docker $(id -nu) reboot Referências  https://docs.docker.com/engine/install/ubuntu/ https://docs.docker.com/compose/install/  "
},
{
	"uri": "/tutorials/git/git-bash-prompt/",
	"title": "Git Bash Prompt",
	"tags": ["git", "bash"],
	"description": "Instalando um git-bash-prompt para melhorar nossa visibilidade no git",
	"content": "Intro Para ter uma melhor visibilidade do que passa em nossos projetos que estão versionados quando estamos trabalhando de forma local, podemos usar ferramentas como é o caso de git-bash-prompt\nInstalação Baixar o repositorio contendo o software\ncd ~ git clone https://github.com/jenciso/bash-git-prompt.git .bash-git-prompt --depth=1 Adicionar algumas linhas dentro do arquivo .bashrc\nGIT_PROMPT_ONLY_IN_REPO=0 GIT_PROMPT_THEME=Single_line_Minimalist source ~/.bash-git-prompt/gitprompt.sh    Testando Baixar qualquer repositorio git. Ex: https://github.com/jenciso/node-express-azure e fazemos uma simples modificação\ngit clone https://github.com/jenciso/node-express-azure cd node-express-azure rm README.md Agora podemos ver que estamos na branch master e o shell nos indica que temos um cambio em nosso repositorio.\n   "
},
{
	"uri": "/tutorials/kvm/kvm-install/",
	"title": "KVM - Instalacão",
	"tags": ["kvm"],
	"description": "Instalando KVM",
	"content": "Requisitos  Ubuntu Linux 18.04 ou superior  Procedimento Passo 1: Verificar Verificar se nosso sistema suporta hardware virtualization\negrep -c '(vmx|svm)' /proc/cpuinfo  Se a saida é maior que zero, nosso sistema suporta virtualização. Esta tudo ok.\n Agora instalar kvm-ok para saber se o servidor pode rodar hardware accelerated KVM\nsudo apt install cpu-checker sudo kvm-ok   Passo 2: Instalar KVM sudo apt update sudo apt install qemu qemu-kvm libvirt-bin bridge-utils virt-manager   Passo 3: Start \u0026amp; enable libvirtd service sudo service libvirtd start sudo update-rc.d libvirtd enable service libvirtd status   Referências  https://www.linuxtechi.com/install-configure-kvm-ubuntu-18-04-server/  "
},
{
	"uri": "/tutorials/",
	"title": "💻 Tutoriais",
	"tags": ["Tutoriais"],
	"description": "Tutoriais diversos",
	"content": "Tutoriais Os tutoriais foram classificados por tópicos. Todos eles tem como objetivo ser simples e bem praticos.\n"
},
{
	"uri": "/tutorials/git/git-part1/",
	"title": "Git (Parte 1)",
	"tags": ["git"],
	"description": "Tutorial de GIT",
	"content": " Este tutorial esta baseado do seguinte documento: https://githowto.com\n 1. Prerequisitos  Instalar git-bash-prompt seguindo este tutorial Ter uma estacao de trabalho Linux  2. Preparação Configurando nome e endereço de e-mail\ngit config --global user.name \u0026#34;Seu Nome Completo\u0026#34; git config --global user.email \u0026#34;seu_email@sua_empresa.com\u0026#34; Opções de Instalação: términos de linhas (Linux):\ngit config --global core.autocrlf input git config --global core.safecrlf warn   3. Criando o projeto git Vamos a criar um repositório git \u0026ldquo;hello\u0026rdquo; e uma página hello.html com o seguinte conteúdo: \u0026ldquo;Hello, World\u0026rdquo;\nCrie uma página de \u0026ldquo;Hello, World\u0026rdquo; e inicialize o repositório\nmkdir hello \u0026amp;\u0026amp; cd hello echo \u0026#34;Hello, World\u0026#34; \u0026gt; hello.html git init Adicione a página ao repositório:\ngit add hello.html git commit -m \u0026#34;First Commit\u0026#34;   4. Conferindo o status do repositório Use o comando git status para checar o estado atual do repositório.\ngit status   5. Fazendo modificações Modificar a página hello.html com o seguinte conteúdo:\n\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; Conferindo o status:\ngit status   Notar que:\n O git sabe que o arquivo hello.html foi modificado, mas essas modificações ainda não sofreram commit para o repositório. A mensagem de status oferece dicas sobre o que fazer em seguida. Se você quiser adicionar essas modificações para o repositório, use git add. Para desfazer as modificações use git checkout.  6. Adicionando modificações ao stage Mande o git adicionar as modificações ao stage. Confira o status\ngit add hello.html git status   Observar:\n Modificações no hello.html foram adicionadas ao stage. Isso quer dizer que o git sabe da modificação, mas não é permanente no repositório. O próximo commit incluirá as modificações que estão no stage. Se você decidir não fazer commit da modificação, o comando status vai te lembrar que você pode usar o comando git reset para remover essas mudanças do stage.  7. Colocando em stage e fazendo commits Adicionar algo ao stage no git permite que você continue fazendo modificações no seu diretório de trabalho e, quando decidir que quer interagir com o controle de versão, permite que guarde as mudanças em pequenos commits.\nPense que você editou três arquivos (a. html, b. html e c. html). Depois disso você tem que fazer commit de todas as modificações para que as mudanças em a.html e b.html sejam um único commit, enquanto as mudanças em c.html, que não são lógicamente relacionadas com as duas outras mudanças nos outros dois arquivos, sejam enviadas em um commit diferente.\nEm teoria, você pode fazer o seguinte:\ngit add a.html git add b.html git commit -m \u0026#34;Changes for a and b\u0026#34; git add c.html git commit -m \u0026#34;Unrelated change to c\u0026#34; Separando a adição ao stage e o commit, você pode customizar o que vai em cada commit.\n8. Fazendo commit das modificações Na hora de executar o comando git commit vamos omitor o uso do flag -m, desta forma entramos na edição interativa de comentários para o commit. O git ira abrir o editor configurado a partir desta lista (em ordem de prioridade)\n Variável de ambiente GIT_EDITOR Definição de configuração core.editor Variável de ambiente VISUAL Variável de ambiente EDITOR  No me caso meu editor é \u0026lsquo;vi\u0026rsquo;. Caso deseje modificar seu editor de forma permanente, edite o arquivo ~/.gitconfig\nLogo de executar o commit, iremos colocar como comentario \u0026ldquo;Added h1 tag\u0026rdquo;\n  9. Modificações, não arquivos O git trabalha com as modificações, não com os arquivos.\n Primeira mudança: Adicionando tags padrão de páginas e executando git add hello.html. O novo conteúdo para o arquivo: hello.html será:  \u0026lt;html\u0026gt; \u0026lt;body\u0026gt;  \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add hello.html  Segunda mudança: Adicione os headers do HTML. Agora adicione os headers ( section) na página  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Agora excute:\ngit status   Note que o arquivo hello.html está listado duas vezes no status.\n A primeira mudança (a adição das tags padrão) está no stage e pronta para um commit. A segunda mudança (adição dos headers) não está no stage.  Se você fizesse um commit agora, os headers não teriam sido salvos no repositório.\n Commit: Faça um commit das mudanças que estão no stage (as tags padrão) e então confira novamente o status.  git commit -m \u0026#34;Added standard HTML page tags\u0026#34; git status   O comando status diz que o arquivo hello.html tem modificações não gravadas, mas não está mais em buffer.\n Adicionando a segunda modificação: Adicione a segunda modificação ao stage, depois execute o comando git status  git add . git status git commit -m \u0026#34;Added HTML header\u0026#34;   10. Histórico Usaremos o comando git log\ngit log   Histórico em uma linha:\ngit log --pretty=oneline Controlando a exibição de entradas\ngit log --pretty=oneline --max-count=2 git log --pretty=oneline --since='5 minutes ago' git log --pretty=oneline --until='5 minutes ago' git log --pretty=oneline --author=\u0026lt;your name\u0026gt; git log --pretty=oneline --all Para rever as modificações feitas na última semana\ngit log --all --pretty=format:\u0026quot;%h %cd %s (%an)\u0026quot; --since='7 days ago' Um formato bacana\ngit log --pretty=format:\u0026quot;%h %ad | %s%d [%an]\u0026quot; --graph --date=short   Vamos olhar os detalhes:\n \u0026ndash;pretty=\u0026rdquo;\u0026hellip;\u0026rdquo; define o formato da saída %h é o hash abreviado do commit %d mostra decorações do commit (ex.: head de branches ou tags) %ad é a data do commit %s é o comentário %an é o nome do autor = \u0026ndash;graph fala para o git mostrar a árvore de commits no formato de um gráfico de ASCII \u0026ndash;date=short mantém o formato de data pequeno e simples  Então, toda vez que você quiser ver um log, você terá que digitar muito. Felizmente, nós aprenderemos sobre aliases na próxima lição.\n11. Aliases Adicione as seguintes linhas no arquivo ~/.gitconfig\n[alias] co = checkout ci = commit st = status br = branch hist = log --pretty=format:\\\u0026quot;%h %ad | %s%d [%an]\\\u0026quot; --graph --date=short type = cat-file -t dump = cat-file -p Agora execute:\ngit st git hist   12. Usando versões anteriores Conseguindo os hashes das versões anteriores git hist O resultado será:\n  Confira a data do log e encontre o hash do primeiro commit. Você vai achar ele na última linha do git hist Use o código (os seus 7 primeiros caracteres são suficientes) no comando abaixo. Depois disso, cheque o conteúdo do arquivo hello.html.\ngit checkout \u0026lt;hash\u0026gt; cat hello.html   Voltando para a versão mais atual no branch master git checkout master cat hello.html   ‘master’ é o nome do branch padrão. Ao entrar em um branch pelo seu nome, você vai para a sua versão mais atual.\n13. Adicionando tags a versões Vamos chamar a versão atual do nosso programa \u0026ldquo;Hello\u0026rdquo; de versão 1 (v1).\nCriando a tag do primeiro git tag v1 Tags em versões antigas Vamos adicionar uma tag à versão anterior da nossa atual versão com o nome v1-beta. Nós vamos usar a notação ^ indicando “o pai de v1”. Se a notação v1^ gera problemas, tente usar v1~1 para referenciar a mesma versão. Essa notação significa “a primeira versão antes de v1”.\ngit checkout v1^ cat hello.html   Essa é a versão com as tags \u0026lt;html\u0026gt; e \u0026lt;body\u0026gt;, mas sem \u0026lt;head\u0026gt;. Vamos fazer dessa a versão v1-beta.\ngit tag v1-beta Acessando através do nome da tag git checkout v1 git checkout v1-beta   Vendo tags com o comando tag git tag Vendo tags nos logs git hist master --all   Você pode ver as tags (v1 e v1-beta) listadas no log juntamente com o nome do branch (master). O HEAD mostra o commit em que você está atualmente (v1-beta).\n"
},
{
	"uri": "/tutorials/kvm/",
	"title": "KVM",
	"tags": ["kvm"],
	"description": "Kernel-based Virtual Machine",
	"content": "Kernel-based Virtual Machine Com o KVM podemos criar máquinas virtuais de maneira bem simples. O que nos permitirá criar ambientes de laboratorio numa simples máquina Linux\n"
},
{
	"uri": "/artigos/",
	"title": "✍ Artigos",
	"tags": ["artigos"],
	"description": "Diversos artigos",
	"content": "Artigos Um conjunto de documentos que acrescentaram conhecimento para uso diario\n"
},
{
	"uri": "/tutorials/git/git-part2/",
	"title": "Git (Parte 2)",
	"tags": ["git"],
	"description": "Tutorial de GIT",
	"content": " Este tutorial é a continuação do tutorial Git (Part 1)\n 14. Descartando mudanças locais (antes do stage) Acessando o branch Master Verifique que você esta no último commit do branch master antes de continuar.\ngit checkout master Mude o hello.html Acontece de você modificar o arquivo no seu diretório de trabalho local e às vezes querer descartar as mudanças que você fez commit. É aqui que o comando checkout vai te ajudar.\nFaça mudanças ao arquivo hello.html na forma de um comentário indesejado.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;!-- This is a bad comment. We want to revert it. --\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Confira o status\ngit status   Desfazendo as mudanças no diretório de trabalho cat hello.html git checkout hello.html git status cat hello.html   O comando status mostra que não existem mudanças que não estão no stage no repositório de trabalho. E o “comentário ruim” não está mais no arquivo.\n15. Descartando mudanças no stage (antes do commit) Edite o arquivo e adicione as mudanças ao stage Faça mudanças ao arquivo hello.html na forma de um comentário indesejado.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- This is an unwanted but staged comment --\u0026gt;  \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; E logo adicione o arquivo ao stage.\ngit add hello.html git status   Revertendo a zona de buffer Felizmente, o status informado nos mostra exatamente o que devemos fazer para cancelar mudanças no stage.\ngit reset HEAD hello.html   O comando reset retorna a zona do buffer para HEAD. Isso limpa a zona do buffer das mudanças que nós acabamos de adicionar ao stage.\nO comando reset (padrão) não altera o diretório de trabalho. Logo, o diretório de trabalho ainda tem os comentários indesejados. Nós podemos usar o comando checkout do tutorial anterior para remover as mudanças do repositório de trabalho.\nMudando para a versão do commit git checkout hello.html git status   Nosso diretório de trabalho está limpo novamente.\n16. Desfazendo commits Algumas vezes você percebe que os novos commits estão errados e você quer desfazê-los. Existem várias maneiras de resolver esse problema, mas nós usamos a mais segura aqui.\nPara desfazer o commit, vamos criar um novo commit desfazendo as modificações não desejadas.\nEdite o arquivo e faça um commit Substitua o arquivo hello.html com o seguinte.\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;!-- This is an unwanted but committed change --\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add hello.html git commit -m \u0026quot;Oops, we didn't want this commit\u0026quot; Faça um commit com as novas modificações que desfazem as modificações anteriores Para desfazer o commit, precisamos criar um commit que deleta as modificações feitas pelo commit indesejado.\ngit revert HEAD   Voce tb poderia haver usado o comando git revert HEAD --no-edit. O comando --no-edit pode ser ignorado. Ele era desnecessário para gerar as informações de saída sem abrir o editor.\nConfira o log git hist   A seguir vamos olhar a técnica que pode ser usada para remover o último commit do histórico do repositório.\n17. Removendo um commit de um branch Revert é um comando poderoso da seção anterior que te permite cancelar quaisquer commits para um repositório. Apesar disso, tanto os commits originais quanto os cancelados permanecem visíveis no histórico do branch (quando usamos o comando git log).\nFrequentemente depois que um commit é feito percebemos que ele era um erro. Seria legal ter um comando de desfazer que permitisse deletar o commit incorreto imediatamente. Esse comando preveniria a aparição de um commit indesejado no histórico do git log.\nO comando reset Nós já usamos o comando reset para equiparar o buffer zone e o commit selecionado (commit HEAD foi usado na lição anterior).\nQuando uma referência a um commit é dada (Exemplo: um branch, hash, ou tag name), o comando reset vai\u0026hellip;\n Sobrescrever o branch atual para que ele aponte para o commit correto Opcionalmente resetar o buffer zone para que ele satisfazer o commit especificado Opcionalmente resetar o dirétorio de trabalho para que ele equipare-se ao commit especificado  Cheque nosso histórico git hist   Nós vemos que os dois últimos commits desse branch são \u0026ldquo;Oops\u0026rdquo; and \u0026ldquo;Revert Oops\u0026rdquo;. Vamos removê-los com o comando reset.\nMarque esse branch primeiro Vamos marcar nosso último commit com tag, para que possamos achá-lo após remover commits.\ngit tag oops Resete o commit para o Oops anterior No log de histórico (veja acima), o commit com tag «v1» está fazendo commit sobre um commit anterior incorreto. Vamos resetar o branch para aquele ponto. Como o branch tem uma tag, podemos usar o nome da tag no comando reset (se não possuir uma tag, podemos usar o valor hash).\ngit reset --hard v1 git hist   Nada é perdido para sempre O que acontece com os commits errados? Eles ainda estão no repositório. Na verdade, ainda podemos nos referir a eles. No início da lição, criamos a tag «oops» para o commit cancelado. Vamos dar uma olhada em all (todos) commits.\ngit hist --all   Podemos ver que os commits errados não foram embora. Eles não estão listados mais no branch master mas ainda permanecem no repositório. Eles ainda estariam no repositório caso não tivéssemos colocado uma tag neles, mas só poderíamos referenciá-los por seus nomes hash. Commits não referenciados continuam no repositório até que um software garbage collection é acionado pelo sistema.\nPerigos de resetar Resets em branches locais geralmente são inofensivos. As consequências de quaisquer \u0026ldquo;acidentes\u0026rdquo; podem ser revertidos usando um commit apropriado.\nApesar disso, outros usuários que compartilham o branch podem ficar confusos se o branch compartilhado fica armazenado em repositórios remotos.\n18. Removendo a tag oops A tag oops já fez o seu trabalho. Vamos removê-la e permitir que o garbage collector delete o commit referenciado.\ngit tag -d oops git hist --all   19. Mudando commits Mude a página e faça um commit Coloque um comentário de autor na página.\n\u0026lt;!-- Author: Juan Enciso --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add hello.html git commit -m \u0026quot;Add an author comment\u0026quot; Oops\u0026hellip; precisa do e-mail Depois de fazer o commit, você percebe que todo bom comentário deveria incluir o e-mail do autor. Edite a página hello para fornecer um e-mail.\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Mude o commit anterior Nós não queremos criar outro commit apenas para o e-mail. Vamos mudar o commit anterior e adicionar o endereço de e-mail.\ngit add hello.html git commit --amend -m \u0026quot;Add an author/email comment\u0026quot;   Olhar o histórico git hist   O novo commit \u0026ldquo;author/email\u0026rdquo; substitui o commit original \u0026ldquo;author\u0026rdquo;. O mesmo pode ser obtido usando o comando reset no branch e fazendo novamente o commit com as mudanças.\n20. Movendo arquivos Mova o arquivo hello.html para a pasta lib. Agora criaremos a estrutura do nosso repositório. Vamos mover a página no diretório lib\nmkdir lib git mv hello.html lib git status Movendo arquivos com git, nós notificamos o git sobre duas coisas\n O arquivo hello.html foi deletado. O arquivo lib/hello.html foi criado.  Ambos os fatos vão para stage imediatamente e ficam prontos para o commit. O comando git status reporta que o arquivo foi movido.\nMais um jeito de mover arquivos Um fato positivo sobre o git é que você não precisa se lembrar de controle de versão no momento em que você faz o commit do código. O que poderia acontecer se nós estivéssemos usando a linha de comando do sistema operacional ao invés do comando git para mover arquivos?\nO próximo set de comandos é idêntico às nossas últimas ações. É necessário mais trabalho para o mesmo resultado.\nNós podemos fazer:\nmkdir lib mv hello.html lib git add lib/hello.html git rm hello.html Faça commit do novo diretório Vamos fazer commit dessa mudança.\ngit commit -m \u0026quot;Moved hello.html to lib\u0026quot;   21. Mais informação sobre a estrutura Adicionando index.html Vamos adicionar um arquivo index.html ao nosso repositório. O arquivo a seguir é perfeito para esse propósito.\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026#34;lib/hello.html\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Adicione o arquivo e faça um commit.\ngit add index.html git commit -m \u0026quot;Added index.html.\u0026quot; Agora quando você abrir index.html, você deverá ver uma parte da página hello em uma pequena janela.\n  firefox index.html 22. Dentro do Git: diretório .git O diretório .git Essa é uma pasta especial onde todas as coisas do git estão. Vamos explorar o diretório.\n  Banco de Dados de Objetos ls -C .git/objects/\u0026lt;dir\u0026gt; Você deve ver várias pastas nomeadas com dois caracteres. As duas primeiras letras do hash sha1 do objeto armazenado no git são o nome dos seus diretórios.\nVamos dar uma olhada em uma das pastas nomeadas com dois caracteres. Devem ter arquivos com nomes de 38 caracteres. Esses arquivos contém os objetos armazenados no git. Eles são comprimidos e encriptados, então é impossível ver seu conteúdo diretamente. Vamos dar uma olhada melhor no diretório Git.\n  Arquivo Config cat .git/config   Branches e tags ls .git/refs ls .git/refs/heads ls .git/refs/tags cat .git/refs/tags/v1   Arquivos no subdiretório de tags devem ser familiares pra você. Cada arquivo corresponde a tag anteriormente criada usando o comando git tag. Seu conteúdo não é nada mais que um hash de um commit associado à tag.\nA pasta heads é quase idêntica e é usada não para tags, mas para branches. No momento, nós só temos um branch e tudo que você vê nessa pasta é um branch master.\nArquivo HEAD cat .git/HEAD   Existe uma referência para o branch atual no arquivo HEAD. Nesse momento, ela tem que ser para o branch master.\n23. Dentro do Git: Trabalhando diretamente com objetos do git Procurando pelo último commit git hist --max-count=1   Exibição do último commit Com a hash SHA1, tal como acima\u0026hellip;\ngit cat-file -t \u0026lt;hash\u0026gt; git cat-file -p \u0026lt;hash\u0026gt;   Busca em árvore Nós podemos exibir a árvore referenciada no commit. Isso deveria ser uma descrição do arquivo no nosso projeto (para um commit específico). Use a hash SHA1 da string da árvore listada acima.\ngit cat-file -p \u0026lt;treehash\u0026gt;   Exibir diretório da lib e Exibir o arquivo hello.html git cat-file -p \u0026lt;libhash\u0026gt; git cat-file -p \u0026lt;hellohash\u0026gt;   E aí está. Objetos árvores, objetos de commits e objetos blob são exibidos diretamente do repositório do git. E isso é tudo que tem - árvores, blobs e commits.\nExplore você mesmo O repositório git pode ser explorado manualmente. Tente achar manualmente o arquivo hello.html original do primeiro commit com ajuda da hash SHA1 referenciada no último commit.\n"
},
{
	"uri": "/tutorials/git/git-part3/",
	"title": "Git (Parte 3)",
	"tags": ["git"],
	"description": "Tutorial de GIT",
	"content": " Este tutorial é a continuação do tutorial Git (Part 2)\n 24. Criando um Branch Vamos nomear o nosso novo branch como «style».\ngit checkout -b style git status Nota:\n git checkout -b \u0026lt;branch name\u0026gt; é o atalho de git branch \u0026lt;branch name\u0026gt; seguido por git checkout \u0026lt;branch name\u0026gt; Note que o comando git status avisa que você está no branch style.  Adicione o arquivo style.css touch lib/style.css Arquivo lib/style.css\nh1 { color: red; } Execute:\ngit add lib/style.css git commit -m \u0026#34;Added css stylesheet\u0026#34;   Mude a página principal Atualize o arquivo lib/hello.html para usar o style.css.\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt;  \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add lib/hello.html git commit -m \u0026quot;Hello uses style.css\u0026quot;   Mude o index.html Atualice o arquivo index.html para que ele use style.css\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;lib/style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt;  \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026#34;lib/hello.html\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add index.html git commit -m \u0026quot;Updated index.html\u0026quot;   25. Navegando em Branches Agora o seu projeto possui dois branches:\ngit hist --all   Trocando para o branch master git checkout master cat lib/hello.html   Vamos retornar para o branch do style. git checkout style cat lib/hello.html   26. Mudanças no branch master Enquanto você está mudando o branch style, alguém decide mexer na branch master. Ele adicionou um arquivo README.md.\nCrie um arquivo README.md\n## Tutorial  This is the Hello World example from the git tutorial. Faça um commit das mudanças do arquivo README no branch master.\ngit checkout master git add README.md git commit -m \u0026quot;Added README\u0026quot;   27. Visualizando os diferentes branches Agora nós temos um repositório com dois branches diferentes. Para ver branches e suas diferenças, use o comando log como segue.\ngit hist --all   Nós temos a oportunidade de ver o --graph do git hist em ação. Adicionando a opção --graph ao git log faz com que ele crie uma árvore de commits com a ajuda de caracteres ASCII simples. Nós vemos ambos os branches (style e master) e que o branch atual é o master HEAD. O arquivo index.html adicionado vai antes de ambos branches.\nA flag \u0026ndash;all garante que nós vejamos todos os branches. Por padrão, apenas o branch atual é mostrado.\n28. Merging Merging em um único branch Merge junta as modificações de dois branches em um. Vamos voltar para o branch style e fazer um merge dele com o master.\ngit checkout style git merge master git hist --all   Pelo merge periodico entre os branches master e style, você pode acompanhar quaisquer mudanças ou modificações ocorridas para manter a compatibilidade das mudanças de estilo na linha principal.\nPorém, isso faz com que os gráficos de commits fiquem feios. Mais tarde vamos considerar a relocação como uma alternativa à fusão.\n29. Criando um conflito Voltar para o master e criar o conflito Volte para o branch master e faça as seguintes alterações:\ngit checkout master Arquivo lib/hello.html\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- no style --\u0026gt;  \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World! Life is great!\u0026lt;/h1\u0026gt;  \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; git add lib/hello.html git commit -m 'Life is great!' Visualize os branches\ngit hist --all   Depois de um commit \u0026ldquo;Added README\u0026rdquo; o branch master foi feito um merge com o branch style, mas existe um commit aditional do master, que não foi feito um merge com o branch style.\nA última modificação feita no master entra em conflito com algumas mudanças do style. No próximo passo nós vamos resolver esse conflito.\n30. Resolvendo conflitos Fazer merge do branch master com o style git checkout style git merge master   A primeira seção e a versão do branch atual (style) head. A segunda seção é a versão do branch master.\nResolução do conflito Você precisa resolver o conflito manualmente. Faça mudanças no lib/hello.html para alcançar o seguinte resultado.\n\u0026lt;!-- Author: Juan Enciso (juan.enciso@gmail.com) --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link type=\u0026#34;text/css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; media=\u0026#34;all\u0026#34; href=\u0026#34;style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, World! Life is great!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Merging avançado Git não tem ferramentas gráficas de merging, mas aceita qualquer ferramenta de merge produzida por terceiros. (leia mais sobre essas ferramentas no StackOverflow.)\n31. Realocating como uma alternativa à merge Vamos olhar para as diferenças entre realocating e merge. Para fazer isso, precisamos voltar no repositório no momento antes do primeiro merge e então repetir os mesmos passos realocando ao invés de fazer merge.\nNós usaremos o comando reset para voltar o branch para um estado anterior.\n32. Resetando o branch style Vamos para o branch style no ponto antes de darmos merge com o branch master. Podemos resetar o branch para qualquer commit. Na verdade, isso faz com que o ponteiro do branch aponte para qualquer commit contido na árvore.\nAqui, queremos voltar no style branch para um ponto anterior ao merge com o master. Temos que encontrar o último commit antes do merge\ngit checkout style git hist   É um pouco difícil de ler, mas podemos perceber pelos dados que o commit Updated index.html foi o último no branch style anterior ao merging. Vamos resetar o style branch para esse commit.\ngit reset --hard \u0026lt;hash\u0026gt; git hist --all   Agora no branch style não existem commits de merge no nosso histórico.\n33. Reset do branch master Resetando branch master O modo interativo que adicionamos ao branch master se tornou uma mudança que conflita com as mudanças do branch style. Vamos reverter as mudanças do branch master para o ponto anterior à mudança conflitante. Isso nos permite demonstrar o comando rebase sem nos preocupar com conflitos.\ngit checkout master git hist   O commit \u0026ldquo;Added README\u0026rdquo; está imediatamente antes do modo interativo conflitante ser adicionado. Agora precisamos resetar o branch master para o commit \u0026ldquo;Added README\u0026rdquo; .\ngit reset --hard \u0026lt;hash\u0026gt; git hist --all Examine o log. Ele deve parecer como se tivéssemos retrocedido o repositório para um ponto no tempo anterior a qualquer merge.\n  34. Rebase Então nós voltamos no histórico até antes do primeiro merge e queremos realocar as mudanças do master para o nosso branch style.\nDessa vez nós vamos usar o comando rebase ao invés do merge.\ngit checkout style git rebase master git hist   Merge VS Rebase O resultado do comando rebase parece muito com o do merge. O branch style atualmente contém todas as suas mudanças, além das mudanças do branch master. A árvore de commits, porém, está um pouco diferente. A árvore de commit do branch style foi reescrita para fazer o branch master parte do histórico de commits. Isso faz com que a cadeia de commits seja mais linear e legível.\nQuando usar rebase, quando usar merge? Não use o comando rebase\u0026hellip;\n Se o branch é público e compartilhado. Reescrever tais branches vai atrapalhar o trabalho de outros colegas. Quando o histórico exato de commits do branch é importante (porque o comando rebase reescreve o histórico de commits).  Dadas as recomendações acima, eu prefiro usar rebase para branches locais e de curto prazo e merge para branches em repositórios públicos.\n35. Merging com o branch master Nós mantivemos nosso branch style atualizado em relação ao branch master (usando rebase), mas agora vamos fazer merge das modificações de volta no master.\ngit checkout master git merge style Já que o último commit do master é anterior ao o último commit do branch style, o git consegue fundir em modo de avanço rápido - simplesmente movendo o ponteiro do branch para frente, apontando para o mesmo commit que o branch style.\nConflitos não surgem no fast-forward merge.\n  Confira os logs git hist   Agora o style e o master são idênticos. Verifique:\ngit hist --all 36. Repositórios múltiplos Até agora só trabalhamos com um repositório git. Apesar disso, git é ótimo para trabalhar com vários repositórios. Os repositórios adicionais podem ser armazenados localmente ou acessados por conexão de rede.\nNa próxima seção iremos criar um novo repositório chamado \u0026ldquo;cloned_hello\u0026rdquo;. Nós iremos discutir como mover mudanças de um repositório para o outro, lidando com conflitos que possam surgir.\nNOTA: Nós faremos mudanças em ambas as cópias do nosso repositório. Preste atenção no repositório em que você está em cada estágio das próximas lições.\n37. Clonando repositórios Se você está trabalhando em grupo, é importante que você entenda os próximos 12 capítulos, porque você geralmente terá que trabalhar com repositórios clonados.\ncd .. pwd git clone hello cloned_hello ls -ld hello cloned_hello   38. Examine o repositório clonado Visualizando o histórico do repositório\ncd cloned_hello ls git hist --all   Você verá uma lista de todos os commits no novo repositório, que deveriam ser iguais aos do repositório original. A única diferença deveria ser o nome dos branches.\nBranches remotos Você verá um branch master (HEAD) no histórico. Você também verá branches com nomes estranhos (origin/master, origin/style e origin/HEAD). Nós falaremos deles depois.\n39. O que é origin? git remote git remote show origin   Nós podemos ver que o “origin” do repositório remoto é o repositório hello original. Repositórios remotos são tipicamente guardados em uma máquina separada ou em um servidor centralizado. Porém, como podemos ver, eles também podem apontar para um repositório na mesma máquina. Não tem nada especial sobre o nome “origin”, mas existe uma convenção de usá-lo para o repositório primário central (se houver algum).\n40. Branches remotos Vamos dar uma olhada nos branches do nosso repositório clonado.\ngit branch   Como podemos ver, apenas o branch master está listado. Onde está o branch style? git branch lista apenas os branches locais, por padrão.\nLista dos branches remotos Para ver todos os branches, use o seguinte comando:\ngit branch -a   O Git lista todos os commits do repositório original, mas os branches do repositório remoto não são tratados como os locais. Se nós precisamos do nosso próprio branch style, teremos que criá-lo. Em um minuto você verá como isso é feito.\n41. Mudando o repositório original Faça uma mudança no repositório original hello cd ../hello Faça as seguintes mudanças no arquivo README:\n## Tutorial  This is the Hello World example from the git tutorial. (changed in original) Agora adicione e faça commit dessas mudanças\ngit add README git commit -m \u0026quot;Changed README in original repo\u0026quot;   Agora o repositório original tem mudanças mais recentes que não estão incluídas na versão clonada. Em seguida, vamos receber essas mudanças no repositório clonado.\n42. Trazendo modificações cd ../cloned_hello git fetch git hist --all   Neste momento, o repositório contém todos os commits do repositório original. Porém, eles não estão integrados com os branchs locais do repositório clonado.\nVocê vai ver o commit de nome “Changed README in original repo” no histórico. Perceba que o commit inclui “origin/master” e “origin/HEAD”.\nAgora vamos dar uma olhada no commit “Updated index.html”. Você vai ver que o branch master local aponta para esse commit, não para o commit que acabamos de trazer.\nIsso nos mostra que o comando “git fetch” vai trazer os novos commits do repositório remoto, mas não vai fundir eles com os branches locais.\nCheque o README Nós podemos mostrar que o arquivo README clonado não foi modificado.\ncat README.md   43. Merging as modificações baixadas Faça merge das modificações baixadas no branch master local e agora você deve ver as modificações no arquivo README.md\ngit merge origin/master cat README.md   44. Fazendo pull e merge de modificações Não iremos passar por todo o processo de fazer e dar pull em uma mudança, mas queremos que vocês saibam que:\ngit pull é, na verdade, equivalente a fazer os seguintes passos:\ngit fetch git merge origin/master 45. Adicionando um branch de rastreamento Branches que começam com remotes/origin pertencem ao repositório original. Perceba que, mesmo que você não tenha mais o branch styles, ele sabe que o branch está no repositório original.\nAdicione um branch local que rastreia um branch remoto. git branch --track style origin/style git branch -a git hist --max-count=2   46. Repositórios bare Repositórios bare (sem o diretório de trabalho) são tipicamente usados para compartilhamento.\nCriando um repositório bare cd .. git clone --bare hello hello.git ls -ld hello.git cd hello.git/ ls -l Tipicamente, repositórios terminados em .git são bare. Como você pode ver, não existe nenhum diretório de trabalho no repositório hello.git. Na verdade, ele não é nada mais que o diretório .git de um repositório que não é bare.\n  47. Adicionando um repositório remoto Vamos adicionar o repositório hello.git ao nosso repositório original.\ncd .. cd hello git remote add shared ../hello.git   NOTA: Nós estamos agora no repositório hello.\n48. Submetendo modificações A partir de um repositório limpo, geralmente compartilhado em qualquer servidor de rede, precisamos enviar nossas modificações a outros repositórios. Comece criando uma modificação para ser enviada. Edite o arquivo README.md e faça um commit\n## Tutorial  This is the Hello World example from the git tutorial. (Changed in original and pushed to shared) git checkout master git add README git commit -m \u0026quot;Added shared comment to readme\u0026quot;   Agora envie as modificações para o repositório compartilhado.\ngit push shared master O repositório comum está recebendo nossas modificações enviadas. (Lembre-se, nós adicionamos ele como um repositório remoto na lição anterior).\n  Nota: Tivemos que explicitamente especificar o branch master para submeter as mudanças. Isso pode ser configurado automaticamente, mas eu sempre esqueço o comando. Para fácil administração de seus branches remotos mude para «Git Remote Branch».\n49. Removendo modificações comuns Rapidamente mude para o repositório clonado e extraia as modificações recém enviadas ao repositório comum.\ncd ../cloned_hello Nota: Estamos agora no repositório cloned_hello.\nContinue com \u0026hellip;\ngit remote add shared ../hello.git git branch --track shared master git pull shared master cat README.md   50. Divulgando o seu repositório Existem maneiras diferentes de compartilhar um repositório git na rede. Essa é a mais rápida.\nExecute git server cd .. git daemon --verbose --export-all --base-path=.   Agora, vá ao seu diretório de trabalho num terminal separado.\ngit clone git://localhost/hello.git network_hello cd network_hello ls   Confira se seu vizinho usa git daemon. Troquem seus endereços IP e depois confiram se vocês podem pegar as alterações dos repositórios um do outro.\n"
},
{
	"uri": "/",
	"title": "Docs Planet",
	"tags": [],
	"description": "",
	"content": "Docs Planet O Docs Planet é um repostitorio de conteúdo de tutoriais sobre tecnologias usadas no mundo DevOps\n"
},
{
	"uri": "/tags/git/",
	"title": "git",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/articles/",
	"title": "articles",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/artigos/",
	"title": "artigos",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/bash/",
	"title": "bash",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/artigos/init-config/",
	"title": "Configurações iniciais",
	"tags": ["init"],
	"description": "Primeiros passos para configurar sua estacao de trabalho",
	"content": "Configuração de Sudoers Use sudo sem precisar digitar a senha\necho \u0026quot;`whoami` ALL=(ALL) NOPASSWD:ALL\u0026quot; | sudo tee /etc/sudoers.d/admins Criando par de chaves ssh ssh-keygen   "
},
{
	"uri": "/credits/",
	"title": "Credits",
	"tags": [],
	"description": "Contribuidores do Developer Portal",
	"content": "Contribuidores Juan Enciso @jenciso\nMateus Abdala @MateusAbdala\n "
},
{
	"uri": "/tutorials/docker/",
	"title": "Docker",
	"tags": ["docker"],
	"description": "Conteúdo sobre containers e o mundo Docker",
	"content": "Containers "
},
{
	"uri": "/tags/docker/",
	"title": "docker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tutorials/git/gitflow/",
	"title": "Gitflow",
	"tags": ["git", "gitflow"],
	"description": "Tutorial de Gitflow",
	"content": "Intro Gitflow é um modelo de organização de branches criado por Vincent Driessen, Não é o único modelo de organização de branches, mas sem dúvida é um dos mais usados.\nNomenclatura Gitflow estabelece algumas regras de nomenclaturas para tipos de branches enquanto, ao mesmo tempo, define o que cada tipo de branch faz. Para referência, segue uma lista dos tipos de branches definidos pelo Git Flow e suas respectivas descrições:\n  Branch master - É a branch que contém código em nível de produção, ou seja, o código mais maduro existente na sua aplicação. Todo o código novo produzido eventualmente é juntado com a branch master, em algum momento do desenvolvimento;\n  Branch develop - É a branch que contém código em nível preparatório para o próximo deploy. Ou seja, quando features são terminadas, elas são juntadas com a branch develop, testadas (em conjunto, no caso de mais de uma feature), e somente depois as atualizações da branch develop passam por mais um processo para então ser juntadas com a branch master;\n  Branches feature/[*] - São branches no qual são desenvolvidos recursos novos para o projeto em questão. Essas branches tem por convenção nome começando com feature/ (exemplo: feature/new-layout) e são criadas a partir da branch develop (pois um recurso pode depender diretamente de outro recurso em algumas situações), e, ao final, são juntadas com a branch develop;\n  Branches hotfix/[*] - São branches no qual são realizadas correções de bugs críticos encontrados em ambiente de produção, e que por isso são criadas a partir da branch master, e são juntadas diretamente com a branch master e com a branch develop (pois os próximos deploys também devem receber correções de bugs críticos, certo?). Por convenção, essas branches tem o nome começando com hotfix/ e terminando com o próximo sub-número de versão (exemplo: hotfix/2.1.1), normalmente seguindo as regras de algum padrão de versionamento, como semversion.\n  Branches release/[*] - São branches com um nível de confiança maior do que a branch develop, e que se encontram em nível de preparação para ser juntada com a branch master e com a branch develop (para caso tenha ocorrido alguma correção de bug na branch release/* em questão). Note que, nessas branches, bugs encontrados durante os testes das features que vão para produção podem ser corrigidos mais tranquilamente, antes de irem efetivamente para produção. Por convenção, essas branches tem o nome começando com release/ e terminando com o número da próxima versão do software (seguindo o exemplo do hotfix, dado acima, seria algo como release/2.2.0), normalmente seguindo as regras do versionamento semântico.\n  Um aspecto interessante do Git Flow é que, quando você mistura uma branch release/ ou hotfix/ com a branch master, ele automaticamente cria git tags correspondentes aos merge commits da mistura, facilitando o trabalho de, por exemplo, mudar para uma versão mais antiga, e organizando todo o trabalho.\nTutorial básico de git flow Para esse tutorial básico de git flow, vou assumir que você está com o repositório criado no tutorial basico de git\n1. Instalacão Gitflow é uma extensão ao Git, para instalar ele, simplesmente execute sudo apt-get install git-flow\n  2. Inicializando git-flow Agora, na pasta do repositório criado no tutorial básico de git, execute os comandos para deixar o repositorio somente com a branch master\ngit branch -a git branch -d nova-branch Logo inicializamos o git flow:\ngit flow init -d  A opcão -d, permite configurar o git flow com os nomes default\n   Note que, durante a execução do comando, o Git Flow criará a branch develop e fará git checkout automático para esta branch.\n3. Criando uma feature branch Agora, vamos criar uma nova feature branch? Para fazer isso, execute o comando:\ngit flow feature start recurso-milionario Aquilo irá criar uma nova feature branch chamada recurso-milionario, com o nome feature/recurso-milionario. Antes vamos explorar quais sao as branch q foram criadas:\n  4. Trabalhando na feature branch Nesta nova branch criaremos um arquivo recurso.txt com o conteúdo \u0026ldquo;Este é o melhor recurso criado desde sempre!\u0026rdquo;. Logo executaremos os comandos \u0026ldquo;git add recurso.txt\u0026rdquo; e \u0026ldquo;git commit -m \u0026lsquo;Finished feature\u0026rsquo;\u0026rdquo; para adicionar e commitar o arquivo em questão na feature branch recurso-milionario\necho \u0026#39;Este é o melhor recurso criado desde sempre!\u0026#39; \u0026gt; recurso.txt git add recurso.txt git commit -m \u0026#39;Finished feature\u0026#39;   5. Finalizando os trabalhos na feature branch Com o commit feito, podemos finalmente juntá-lo a branch develop. Para fazer isso, execute o comando\ngit flow feature finish recurso-milionario   Como você pode ver, a branch feature/recurso-milionario foi correspondentemente integrada à branch develop e o git flow fez checkout automático para a branch develop, te mostrando todos os passos feitos.\n6. Criando uma release branch Agora que temos na branch develop os cambios que queriamos ter, vamos criar uma release branch para poder enfim publicar a atualização na branch master. Para fazer isso, execute o comando\ngit flow release start 0.1.0   7. Alterando a release branch Agora, com a release branch criada, vamos apenas fazer uma pequena alteração no arquivo recurso.txt, modificando a frase:\nDe: \u0026ldquo;Este é o melhor recurso criado desde sempre!\u0026rdquo;\nPara: \u0026ldquo;Este talvez seja o melhor recurso criado desde sempre!\u0026rdquo;\nLogo commitaremos a mudança\ngit add recurso.txt git commit -m \u0026#39;Little bug-fix in feature\u0026#39;   Mudanças podem ser feitas antes da branch ser juntada com a branch master\n8. Finalizando a release Com a mudança registrada, vamos enfim juntar a release branch 0.1.0 com a branch master e a branch develop, para isso, vamos usar o comando\ngit flow release finish 0.1.0 Aquilo vai integrar a mudança feita à release branch 0.1.0 com as branches master e develop\n  Como você pode ver acima, o Git Flow abre o editor de texto três vezes:\n  Uma para você editar o texto do merge commit relacionado ao merge entre a release branch 0.1.0 e a branch master\n  Um para a descrição da tag 0.1.0, que será criada pelo Git Flow para facilitar mudanças de versão no software\n  Uma para você editar o texto do merge commit relacionado ao merge entre a branch master e a branch develop\n  9. Criando um hotfix Agora suponhamos que foi encontrado um bug hiper-critico na aplicação (coincidentemente, nesse exemplo, suponhamos que foi no mesmo recurso recém adicionado) e que ele é tão grave que está afetando o uso por todos os usuários da aplicação e por isso precisa ser corrigido com urgência máxima.\nPara corrigir esse bug critico, vamos criar um hotfix usando o comando\ngit flow hotfix start 0.1.1 Aquilo criará uma hotfix branch chamada 0.1.1 que resolve um problema encontrado no release 0.1.0\n  10. Corrigindo na branch hotfix Agora que temos a nossa hotfix branch 0.1.1 criada, vamos editar o arquivo recurso.txt com a correção que queremos aplicar, substituindo a frase:\n\u0026ldquo;Este talvez seja o melhor recurso criado desde sempre!\u0026rdquo;, Para:\n\u0026ldquo;Este talvez não seja o melhor recurso criado desde sempre! Mas é um dos mais legais!\u0026rdquo;\nno arquivo recurso.txt. Logo comitaremos este cambio:\n  11. Finalizando o hotfix Com o \u0026ldquo;bug\u0026rdquo; corrigido e comittado, podemos agora finalizar nossa hotfix branch e com isso juntá-la à branch master e à branch develop. Para fazer isso, basta usar o comando\ngit flow hotfix finish 0.1.1 Aquilo fará todas essas tarefas por nós e ainda criará uma tag para marcar a correção\n  Novamente, como no caso do git flow release finish, estudado acima, o git flow abre o editor três vezes: Uma para editar o merge commit para o merge com a branch master, outra para editar a descrição da tag que será criada pelo Git Flow, e outra para o merge commit para o merge da branch master com a branch develop.\nConclusões O Gitflow é um modelo de organização de branches é ideal para trabalhar com projetos em equipe, pois permite que cada membro da equipe trabalhe em cada feature branch com maestria e ainda resolva bugs importantes quando eles forem encontrados.\nReferências  http://github.com/nvie/gitflow  "
},
{
	"uri": "/tags/gitflow/",
	"title": "gitflow",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/init/",
	"title": "init",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/kvm/",
	"title": "kvm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tutorials/kvm/kvm-bridge/",
	"title": "KVM - Bridge Setup",
	"tags": ["kvm"],
	"description": "Configurando KVM em modo bridge",
	"content": "Requisitos  KVM instalado Ter uma interfaz de rede ethernet (não wireless) Ubuntu 18.04 ou superior  Procedimento Verificando qual é o nome da minha interfaz de rede\nnmcli device status  Observe o resultado da columna DEVICE\n Com esse dado configuramos via netplan a configuração bridge adicionando um arquivo yaml.\nsudo vi /etc/netplan/50-cloud-init.yaml Copiar um conteúdo similar. No me caso o DEVICE da minha NIC é enp2s0:\nnetwork: version: 2 ethernets: enp2s0:  dhcp4: yes dhcp6: no bridges: br0: interfaces: [enp2s0]  dhcp4: yes dhcp6: no Logo aplicamos os cambios:\nsudo netplan apply sudo networkctl status -a Aqui podemos reiniciar nosso computador para poder verificar que as configurações persistem.\nsudo reboot Referências  https://netplan.io/examples/ https://webby.land/2018/04/27/bridging-under-ubuntu-18-04/ https://github.com/jenciso/notes/blob/master/KVM.md https://askubuntu.com/questions/1106766/netplan-wireless-bridge-ubuntu-18 https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/  "
},
{
	"uri": "/tutorials/kvm/kvm-provision/",
	"title": "KVM - Provision",
	"tags": ["kvm"],
	"description": "Provisionando maquinas virtuais de maneira simples",
	"content": "Requisitos  KVM instalado Ubuntu 18.04 ou superior Usar uma conta com privilegios de root (sudo)  Instalação cd ~ git clone https://github.com/jenciso/kvm-provision Preparação Precisamos baixar uma imagem base para poder usar na criacação de VM\u0026rsquo;s. Usaremos a image Centos 7 ja preperada para trabalhar com cloud-init. Colocaremos esta imagem na pasta boot do libvirt. Execute o seguinte comando:\nsudo curl -fSL -C - http://cloud.centos.org/centos/7/images/CentOS-7-x86_64-GenericCloud.qcow2 \\  -o /var/lib/libvirt/boot/CentOS-7-x86_64-GenericCloud.qcow2 Para poder executar alguns comandos do kvm, precisamos adicionar nosso usuario ao grupo libvirt, e para que os cambios sejam efetivados temos q sair da sessao e volver ingressar\nsudo usermod -a -G libvirt `whoami` logout Começando Criando uma VM (Virtual Machine)\n./new-vm.sh centos7  Esta VM irá ter a IP: 192.168.122.10. O user é centos e o password será SuperSecret2012.  Entrando na VM via console:\nsudo virsh console centos7  Para sair use: Ctrl + ]\n Entrando via SSH\nssh centos@192.168.122.10 Apagando a VM\n./del-vm.sh centos7  Apaga a VM e todo seu conteúdo, inclusive os discos duros\n Mais comandos Copiando suas Chaves SSH Nossa chave SSH publica pode ser colocada no parametro SSH_KEY_0, de tal maneira que consigamos acessar ao servidor virtual sem precisar user/password.\nSe ainda não criou um par de chaves ssh para seu usuario, siga este procedimento. Logo disso, voce ira ter o arquivo ~/.ssh/id_rsa.pub. Copie e cole o conteúdo desse arquivo dentro do arquivo config.conf exatamente como o valor da variavel SSH_KEY_0.\nSSH_KEY_0=ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDYN0xPPa9KV0pZ5vNyet5e5fvWHNCgOTJ5ON9SHef3d Criando uma VM com uma configuração específica Crie a VM demo01 com 1GB de RAM, 2 VCPUs e com a IP 192.168.122.12\n./new-vm.sh -n demo01 -m 1024 -c 2 -i 192.168.122.12 Usando um novo password para suas VM\u0026rsquo;s Cambiando o password default para este valor: MySuperPassword, precisamos executar o comando:\nopenssl passwd -1 -salt SaltSalt MySuperPassword Com a saida desse comando, defina a variavel PASSWORD:\nPASSWORD='$1$SaltSalt$jjGsH9DHuY/4Vda.6JZVH1'\n Dessa forma, a proxima VM ira ter o password MySuperPassword para o user centos\n Aumentando o tamanho do disco duro É só editar a variavel:\nDISK_SIZE=40G\n Aquilo ira criar uma VM com 40GB de espaco de disco\n Adicionando um novo disco Caso a VM tenha como nome centos7 e queramos ter um novo disco adicional de 60GB.\n./add-disk.sh -n centos7 -d vdb -s 60G Listar todas as VM\u0026rsquo;s criadas virsh list --all Gestione as VM\u0026rsquo;s em modo grafico virt-manager Ira carregar o seguinte gestor de VMs\n Demo   Referencias  http://blog.programster.org/kvm-creating-thinly-provisioned-guests  "
},
{
	"uri": "/artigos/semversion/",
	"title": "Semantic Version",
	"tags": ["semversion"],
	"description": "Versionamento Semantico",
	"content": "Intro O versionamento semântico hoje é um dos padrões de versionamento mais usados e conhecidos.\nTem o objetivo de evitar que atualizações de dependência quebrem o seu software indevidamente, enquanto permitindo que você tenha uma noção do status de estabilidade do software (se é \u0026ldquo;seguro\u0026rdquo; usar em produção, por exemplo) e possa identificar se uma nova versão possui apenas novos recursos ou se possui apenas correções de bugs, por exemplo.\nRegras Todo padrão tem regras, e com o versionamento semântico não poderia ser diferente. Existem 11 regras bem definidas e documentadas no site oficial\nMas o que é Semantic Version? "
},
{
	"uri": "/tags/semversion/",
	"title": "semversion",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/tutoriais/",
	"title": "Tutoriais",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/links/",
	"title": "📑 Links",
	"tags": ["artigos", "articles"],
	"description": "Material coletado no dia a dia",
	"content": "Git Artigos  https://www.hostinger.com.br/tutoriais/git-branch/ https://www.xpertup.com/blog/technology/git-and-github-fundamentals/ https://dev.to/usmslm102/git-cheat-sheet-4f5a  Git Tutoriais  https://www.atlassian.com/git/tutorials https://try.github.io/ https://www.vogella.com/tutorials/Git/article.html  Git Merge  https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1  Gitflow  https://medium.com/@olivier.bossel/git-flow-the-right-way-to-go-f2a65c315818  Docker Tutoriais  https://www.docker.com/101-tutorial https://docker-curriculum.com/ https://www.ionos.es/digitalguide/servidores/configuracion/tutorial-docker-instalacion-y-primeros-pasos/  CORS  https://dev.to/lydiahallie/cs-visualized-cors-5b8h  "
}]